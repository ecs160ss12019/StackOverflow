package com.stackoverflow.malwareinvaders.main_functions;

import android.graphics.Bitmap;
import android.graphics.RectF;

class MalwareApp extends Entities {
    // Use mRect to track the position of the MalwareApp
    // Later can use mRect and math relations for collision detections
    // Use other float member variables to track the size of the MalwareApp
    private float mXVelocity;
    private float mAppWidth;
    private float mAppHeight;

    // This Signal object are public because they can be directly accessed by the game engine
    Signal mSignal;

    // This SignalType object is used to start a time counter and randomly drop a random type of shot every 5-10 seconds
    // But only 3 such shots can appear on the screen, we will control them in MalwareInvader
    SignalType msType;

    // I'm going to draw a Bitmap image of each Malware and want to store it's location
    private Bitmap image;
    private float imgXCord;
    private float imgYCord;

    // Some getters and setters because needs to be set original image to store it here and get to draw the image.
    Bitmap getImg(){ return image; }
    float getImgX() { return imgXCord; }
    float getImgY() { return imgYCord; }
    void setImg(Bitmap img) { image = img; }

    // This is for the image of Malware App's missiles

    // Design the constructor method
    // It is called by mMalwareApp = new MalwareApp(mScreenX);
    // In the MalwareInvader class
    MalwareApp(int screenX) {
        super();
        // Make the MalwareApp 5% of the screen width
        // This is arbitrary at this point
        mAppWidth = screenX / 18;
        mAppHeight = screenX / 18;

        // initialize the signal ready for the phoenix
        mSignal = new Signal(screenX);

        // initialize the signal type
        msType = new SignalType();

        mRect = new RectF();
    }

    void fireSignal(int velocity){
        mSignal.createSignal((int)mRect.centerX(),(int)mRect.centerY(), velocity);
    }

    // Return a reference to mRect to MalwareInvader
    RectF getRect() {
        return mRect;
    }

    void update(long fps) {
        if (this.isDying()){
            this.die();
        }

        mRect.left = mRect.left + (mXVelocity / fps);

        // Match up the bottom right corner
        // based on the size of the MalwareApp
        mRect.right = mRect.left + mAppWidth;
        mRect.bottom = mRect.top + mAppHeight;

        imgXCord = mRect.left;
        imgYCord = mRect.top;
    }

    void updateVerticalPosition(int screenY) {
        mRect.top = mRect.top + (screenY / 20);
    }

    // Reverse the horizontal direction of travel
    void reverseXVelocity(){
        mXVelocity = -mXVelocity;
    }

    // Pass screenY, resolution of the screen, in order to set the
    // velocity of App in X-direction
    // Configure the left and top of the ball to 0 and 0 respectively
    // code position of the right and bottom of the MalwareApp
    // according to its size First MalwareAPP starts at the left-top
    // corner of the game
    void reset(int x, int y, int screenX, int screenY) {
        this.setVisible(true);
        this.setDying(false);
        mRect.left = (screenX / 10) * x;
        mRect.top = (screenY / 20) * y;
        mRect.right = mRect.left + mAppWidth;
        mRect.bottom = mRect.top + mAppHeight;
        // The speed of the MalwareApp moves in the game
        mXVelocity = (screenY / 20);

        imgXCord = mRect.left;
        imgYCord = mRect.top;

        // reset all the signal
        mSignal.setVisible(false);
    }

    // Depends on the specified condition, we can increase the speed
    // of MalwareApp at certain stage
    void increaseVelocity(){
        // increase the speed by 10%
        mXVelocity = mXVelocity * 1.1f;
    }

    // If MalwareApp hits the firewall, fireWall, Phoneix3000 will disappear
}
