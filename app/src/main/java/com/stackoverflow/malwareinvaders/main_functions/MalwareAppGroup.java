package com.stackoverflow.malwareinvaders.main_functions;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.RectF;
import android.util.Log;

import java.util.ArrayList;
import java.util.Random;

/**
 * This is a data class holds and handles all the enemies object MalwareApp in game. It is useful
 * to solve the data clump issue on our Malware Invader game class. 
 */

// This class organize a list of MalwareApps

class MalwareAppGroup {

    private ArrayList<MalwareApp> mMalwareAppGroup;
    private int numColumns;
    private Context mContext;
    Integer[] malwareapp1id = {
            R.drawable.ins1,
            R.drawable.ins2
    };
    Integer[] malwareapp2id = {
            R.drawable.facebook,
            R.drawable.facebook2
    };
    Integer[] malwareapp3id = {
            R.drawable.chrome4,
            R.drawable.chrome3,
            R.drawable.chrome2,
            R.drawable.chrome1
    };
    Bitmap[] malware1Array = new Bitmap[2];
    Bitmap[] malware2Array = new Bitmap[2];
    Bitmap[] malware3Array = new Bitmap[4];
    MalwareAppGroup(int mScreenX,Context mContext, int numColumns_input) {
        float imgSize = 0;
        mMalwareAppGroup = new  ArrayList<>();
        numColumns = numColumns_input;
        for (int i = 0; i < 3; i++){
            for (int j = 0; j < numColumns; j++){
                if (i==0){
                    EasyMalwareApp malwareApp = new EasyMalwareApp(mScreenX,mContext);
                    imgSize = malwareApp.width;
                    mMalwareAppGroup.add(malwareApp);
                } else if (i == 1){
                    NormalMalwareApp malwareApp = new NormalMalwareApp(mScreenX,mContext);
                    mMalwareAppGroup.add(malwareApp);
                } else {
                    HardMalwareApp malwareApp = new HardMalwareApp(mScreenX,mContext);
                    mMalwareAppGroup.add(malwareApp);
                }
            }
        }
        this.mContext = mContext;
        for(int i = 0; i < 2; ++i){
            Bitmap img = BitmapFactory.decodeResource(mContext.getResources(), malwareapp1id[i]);
            img = Bitmap.createScaledBitmap(img, (int)imgSize, (int)imgSize, true);
            malware1Array[i] = img;
        }
        for(int i = 0; i < 2; ++i){
            Bitmap img = BitmapFactory.decodeResource(mContext.getResources(), malwareapp2id[i]);
            img = Bitmap.createScaledBitmap(img, (int)imgSize, (int)imgSize, true);
            malware2Array[i] = img;
        }
        for(int i = 0; i < 4; ++i){
            Bitmap img = BitmapFactory.decodeResource(mContext.getResources(), malwareapp3id[i]);
            img = Bitmap.createScaledBitmap(img, (int)imgSize, (int)imgSize, true);
            malware3Array[i] = img;
        }

    }

    ArrayList<MalwareApp> getmMalwareAppGroup() {
        return mMalwareAppGroup;
    }

    void reset(int mScreenX, int mScreenY, int mLevel, int numColumns) {
        for (int i = 0; i < 3; i++){
            for (int j = 0; j < numColumns; j++){
                mMalwareAppGroup.get(i*numColumns+j).reset(j,i,mScreenX,mScreenY, mLevel, numColumns);
                Log.d("Malware App Position: ",""+mMalwareAppGroup.get(i*numColumns+j).getRect().bottom );
            }
        }
    }

    boolean isAllMalmareAppDead(){
        for(MalwareApp ma : mMalwareAppGroup){
            if(ma.isAlive()) {
                return false;
            }
        }
        return true;
    }


    void tryFireSignal(int mScreenY){
        // First let's count the number of signals visible in the screen
        int msCount = 0;
        for (MalwareApp mApp: mMalwareAppGroup) {
            if (mApp.mSignal.isAlive())
                msCount++;
        }

        // now check if any MalwareApp wants to Fire Signal alternating from start (i) or last (j)
        for (MalwareApp mApp : mMalwareAppGroup) {
            if (!mApp.mSignal.isAlive() && mApp.isAlive()) {
                if (mApp.mSignal.msType.getShootTime() < (System.nanoTime() - mApp.mSignal.msType.signalTime)/1000000000) {
                    if (msCount < 3) {
                        mApp.fireSignal(mScreenY);
                        msCount++;
                    } else {
                        mApp.mSignal.msType.reset(System.nanoTime());
                    }
                }
            }
        }

    }

    void update(long mFPS){
        for (MalwareApp a : mMalwareAppGroup){
            a.update(mFPS);
            if (a.mSignal.isAlive()){
                a.mSignal.update(mFPS);
            }
        }
    }

    void detectCollisions(MalwareInvader mInv){
        detectSignalCollisions(mInv);
        detectMalwareCollisions(mInv);
    }

    void detectSignalCollisions(MalwareInvader mInv){
        for (MalwareApp mApp : mMalwareAppGroup) {
            if (mApp.mSignal.isAlive()) {
                // Has the signal hit the bottom
                if (mApp.mSignal.getBetweenRect().top > mInv.gameConf.mScreenY) {
                    // die when the signal went to top of the screen
                    mApp.mSignal.setAlive(false);
                    mApp.mSignal.msType.reset(System.nanoTime());
                }
                // Has the signal hit a Firewall block
                for (Firewall a : mInv.getmFirewall()) {
                    if (RectF.intersects(a.getRect(), mApp.mSignal.getBetweenRect())) {
                        if (a.checkCollision(mApp.mSignal.getBetweenRect())) {
                            //Phoenix Signal should die when it hits any Firewall block
                            mApp.mSignal.setAlive(false);
                            mApp.mSignal.msType.reset(System.nanoTime());
                            break;
                        }
                    }
                }
                // Has the Malware signal hit Phoenix 3000, then decrease a life
                if (mInv.getmPhoenix().isAlive()) {
                    if (RectF.intersects(mInv.getmPhoenix().getRect(), mApp.mSignal.getBetweenRect())) {
                        mInv.mV.vibrate(400);
                        mInv.getmPhoenix().isExploding = true;
                        SoundManager.playEffect(2); // playEffect explosion effect
                        mApp.mSignal.setAlive(false);
                        mApp.mSignal.msType.reset(System.nanoTime());
                        mInv.gameConf.decLives();
                        if (mInv.gameConf.mLives == 0) {
                            mInv.setmPaused(true);
                            mInv.setmPlaying(false);
                            mInv.endGame();
                        }
                    }
                }
            }
            mApp.mSignal.updateBetweenRect();
        }
    }

    void detectMalwareCollisions(MalwareInvader mInv){
        for (MalwareApp mApp : mMalwareAppGroup) {
            if (mApp.isAlive()){
                //Has MalwareInvader collides with the phoenix
                if(RectF.intersects(mInv.getmPhoenix().getRect(), mApp.getRect())) {
                    mInv.getmPhoenix().isExploding = true;
                    mInv.setmPaused(true);
                    mInv.setmPlaying(false);
                    mInv.mV.vibrate(1000);
                    mInv.endGame();
                    break;
                }
                // Has MalwareInvader hits the edge of the screen
                // Bottom
                if(mApp.getRect().bottom > mInv.gameConf.mScreenY){
                    mInv.setmPaused(true);
                    mInv.setmPlaying(false);
                    mInv.mV.vibrate(1000);
                    mInv.endGame();
                    break;
                }
                // Top: MalwareApp won't reach the top of the screen
                // Left
                if(mApp.getRect().left < 0) {
                    for (int j = 0; j < 3*numColumns; j++){
                        mMalwareAppGroup.get(j).updateVerticalPosition(mInv.gameConf.mScreenY);
                        mMalwareAppGroup.get(j).reverseXVelocity();
                        mMalwareAppGroup.get(j).increaseVelocity();
                        mMalwareAppGroup.get(j).update(mInv.getmFPS());
                    }
                    break;
                }
                // Right
                if(mApp.getRect().right > mInv.gameConf.mScreenX){
                    for (int j = 0; j < 3*numColumns; j++) {
                        mMalwareAppGroup.get(j).updateVerticalPosition(mInv.gameConf.mScreenY);
                        mMalwareAppGroup.get(j).reverseXVelocity();
                        mMalwareAppGroup.get(j).increaseVelocity();
                        mMalwareAppGroup.get(j).update(mInv.getmFPS());
                    }
                    break;
                }
            }
        }
    }

    public void draw(Canvas mCanvas, Paint mPaint) {
        for (MalwareApp a : mMalwareAppGroup) {
            if (a.isAlive()){
                //mCanvas.drawRect(a.getRect(),mPaint);
                int type = a.gettype();
                if (type == 2){
                    if(a.aninumber  == 0 || a.aninumber == 12){
                        Random rand = new Random();
                        int n = rand.nextInt(2);
                        a.random = n;
                        if(n == 1){
                            mCanvas.drawBitmap(malware2Array[0], a.getImgX(), a.getImgY(), mPaint);
                        }else{
                            mCanvas.drawBitmap(malware2Array[1], a.getImgX(), a.getImgY(), mPaint);
                        }
                        if (a.aninumber == 0){
                            a.aninumber = a.aninumber + 1;
                        }else{
                            a.aninumber = 1;
                        }
                    }else{
                        mCanvas.drawBitmap(malware2Array[a.random], a.getImgX(), a.getImgY(), mPaint);
                        a.aninumber += 1;
                    }

                }else if(type == 1){
                    if(a.isopen){
                        mCanvas.drawBitmap(malware1Array[1], a.getImgX(), a.getImgY(), mPaint);
                        a.aninumber = a.aninumber + 1;
                        if(a.aninumber == 48){
                            a.isopen = false;
                            a.aninumber = 0;
                        }
                    }else{
                        mCanvas.drawBitmap(malware1Array[0], a.getImgX(), a.getImgY(), mPaint);
                    }
                }else if(type == 3){
                    mCanvas.drawBitmap(malware3Array[a.aninumber/12], a.getImgX(), a.getImgY(), mPaint);
                    a.aninumber = a.aninumber + 1;
                    if(a.aninumber >= 48){
                        a.aninumber = 0;
                    }
                }
                //mCanvas.drawBitmap(a.getImg(), a.getImgX(), a.getImgY(), mPaint);
            }
        }
        for (MalwareApp mApp : mMalwareAppGroup) {
            if (mApp.mSignal.isAlive()) {
                mCanvas.drawBitmap(mApp.mSignal.getImg(), mApp.mSignal.getImgX(), mApp.mSignal.getImgY(), mPaint);
            }
        }
    }

    void resetTime() {
        for (MalwareApp mApp: mMalwareAppGroup) {
                mApp.mSignal.msType.reset(System.nanoTime());
                mApp.mSignal.setAlive(false);
        }
    }

}
