package com.stackoverflow.malwareinvaders.main_functions;

import android.content.Context;
import android.content.Intent;
import android.content.res.AssetManager;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.PointF;
import android.graphics.RectF;
import android.graphics.Typeface;
import android.os.MessageQueue;
import android.util.Log;
import android.util.SparseArray;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.os.Vibrator;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;

/**
 * SurfaceView is a descendant of View and now PongGame is, by inheritance, also a type of View
 * We can use SurfaceView from which our game class is derived to handel all our drawing requirements
 *
 */
public class MalwareInvader extends SurfaceView implements Runnable {
    /**
     * The DEBUGGING flag that tells if we want to debug code
     */
    private final boolean DEBUGGING = true;


    /**
     * Objects that we needed to do the drawing
     */
    private SurfaceHolder mOurHolder;
    private Canvas mCanvas;
    private Paint mPaint;


    // Hold context of MalwareInvaderActivity so we can end game
    private Context mContext;

    /**
     * The numbers of frames per second we get
     * Reinitialized every frame of animation around 60 times per second
     * It will be passed into each of the game objects (every frame of animation) so that
     * they can calcualte how much time has elapsed and can then derive how far to move
     */
    private long mFPS;
    /**
     * The number of milliseconds in a second
     * use this variable in calculations as it will make our code cleared .
     */
    private final int MILLIS_IN_SECOND = 1000;

    /**
     * Holds the resolution of the screen
     * mScreenX : hold the horizontal resolution of the screen
     * mScreenY : hold the vertical resolution of the screen
     */
    private int mScreenX;
    private int mScreenY;
    /**
     * The size of text we need
     */
    private int mFontSize;
    private int mFontMargin;

    // Number of firewalls, can ask user for input to increase/decrease difficulty.
    // We should keep it between 0-3
    // Need to fix code to position the firewalls correctly depending on how many firewall it needs to fit on the screen.
    private int numFirewall = 3;

    /**
     * The game objects
     */
    Phoenix3000 mPhoenix;
    private ArrayList<MalwareApp> mMalwareAppGroup;
    private ArrayList<Firewall> mFirewall;
    private SuperMalware mSuperMalware;
    private DropItem mDropItem;

    /**
     * The current score and lives remaining and which level user is on
     */
    private int mScore;
    private int mLives;
    private int mLevel;

    /** Here is the Thread and two control variables */
    private Thread mGameThread = null;
    /** This volatile variable can be accessed from inside and outside the thread*/
    private volatile boolean mPlaying ;
    private boolean mPaused = true;

    // We'll use this to randomize scores and time when SuperMalware appears
    Random rand = new Random();

    // This is used to keep track of what time from starting/createSignal time should SuperMalware fly.
    long smGoTime;

    // This is used to track the starting point of a time instance. After a random smGoTime after the smRunTime, SuperMalware will fly.
    long smRunTime;

    // This is used to hold if we need to createSignal our System.nanoTime() or not
    boolean smTimeReset = true;

    // asset manager
    AssetManager assetManager;

    // These variables will be used to hold the image and pass it to the classes for storing them
    Bitmap img;
    Bitmap resizedImg;

    // These variables are the images of 3 types of missiles, their location however is being updated by MalwareApp
    Bitmap slowVirus;
    Bitmap mediumVirus;
    Bitmap fastVirus;
    Bitmap[] explosionArray = new Bitmap[12];
    Vibrator mV;


    // Hold the gesture listner that notifie users when a particular touch event has occurred.
    private GestureDetector mDoubleTapDetector;
    private float mLastTouchX;
    // hold the total distance moving left
    private float mLeftMoving = 0;
    // hold the total distance moving right
    private float mRightMoving = 0;


    /**
     * The MalwareInvader constructor : Initialize the resolution size of the screen.
     * executed from MalwareInvaderActivity
     * @param context : providing MalwareInvader with a reference to android activity
     * @param x :  horizontal screen size in pixels
     * @param y : vertical screen size in pixels
     */
    public MalwareInvader (Context context, int x, int y){
        // Super .. calls the parent class : constructor of SurfaceView provided by Android
        super(context);
        this.mContext = context;
        mV = (Vibrator)getContext().getSystemService(Context.VIBRATOR_SERVICE);
        //Initialize the resolution of screen with the values passed in as parameters
        mScreenX = x;
        mScreenY = y;
        // Font is 5% (1/20th) of screen width
        mFontSize = mScreenX / 15;
        // Margin is 1.5% (1/75th) of screen width
        mFontMargin = mScreenX / 75;

        // Initialize the objects ready for drawing with getHolder is a method of SurfaceView
        // GetHolder method returns a reference which is initialized to mHolder so mHolder is now
        // that reference
        mOurHolder = getHolder();
        mPaint = new Paint();
        assetManager = context.getAssets();


        /* Initialize the game objects */
        // Initialize malwareapp group
        mMalwareAppGroup = new ArrayList<>();
        for (int i = 0; i < 3; i++){
            for (int j = 0; j < 6; j++){
                MalwareApp mMalwareApp = new MalwareApp(mScreenX);
                // This following lines of code get the image "malwareapp#.png", resize it to MalwareApp size, and passes it to MalwareApp class for storage
                if (i == 0) {
                    img = BitmapFactory.decodeResource(getResources(), R.drawable.malwareapp1);
                    resizedImg = Bitmap.createScaledBitmap(img, mScreenX/18, mScreenX/18, true);
                    mMalwareApp.setImg(resizedImg);
                } else if (i == 1) {
                    img = BitmapFactory.decodeResource(getResources(), R.drawable.malwareapp2);
                    resizedImg = Bitmap.createScaledBitmap(img, mScreenX/18, mScreenX/18, true);
                    mMalwareApp.setImg(resizedImg);
                } else {
                    img = BitmapFactory.decodeResource(getResources(), R.drawable.malwareapp3);
                    resizedImg = Bitmap.createScaledBitmap(img, mScreenX/18, mScreenX/18, true);
                    mMalwareApp.setImg(resizedImg);
                }
                mMalwareAppGroup.add(mMalwareApp);
            }
        }

        // This following lines of code get the image for slow, medium, and fast virus
        // Resize them to signal size, and store it
        img = BitmapFactory.decodeResource(getResources(), R.drawable.slow);
        resizedImg = Bitmap.createScaledBitmap(img, mScreenX/40, mScreenX/20, true);
        slowVirus = resizedImg;

        img = BitmapFactory.decodeResource(getResources(), R.drawable.medium);
        resizedImg = Bitmap.createScaledBitmap(img, mScreenX/40, mScreenX/20, true);
        mediumVirus = resizedImg;

        img = BitmapFactory.decodeResource(getResources(), R.drawable.fast);
        resizedImg = Bitmap.createScaledBitmap(img, mScreenX/40, mScreenX/20, true);
        fastVirus = resizedImg;

        Integer[] explosionid = {
                R.drawable.explosion1,
                R.drawable.explosion2,
                R.drawable.explosion3,
                R.drawable.explosion4,
                R.drawable.explosion5,
                R.drawable.explosion6,
                R.drawable.explosion7,
                R.drawable.explosion8,
                R.drawable.explosion9,
                R.drawable.explosion10,
                R.drawable.explosion11,
                R.drawable.explosion12,

        };
        for(int i = 0; i < 12; ++i){
            img = BitmapFactory.decodeResource(getResources(), explosionid[i]);
            //resizedImg = Bitmap.createScaledBitmap(img, mScreenX/2, mScreenX/2, true);
            explosionArray[i] = img;
        }

        mScore = 0;
        mLives = 3;
        mLevel = 0;


        // Initialize Phoenix
        mPhoenix = new Phoenix3000(mScreenX,mScreenY);
        // This following lines of code get the image "phoenix3000.png", resize it to Phoenix size, and passes it to Phoenix class for storage
        img = BitmapFactory.decodeResource(getResources(), R.drawable.pheonix3000);
        resizedImg = Bitmap.createScaledBitmap(img, mScreenX/8, mScreenX/8, true);
        mPhoenix.setImg(resizedImg);


        // This following lines of code get the image "signal.png", resize it to signal size, and passes it to Phoenix class to send to Signal class for storage
        img = BitmapFactory.decodeResource(getResources(), R.drawable.signal);
        resizedImg = Bitmap.createScaledBitmap(img, mScreenX/50, mScreenX/15, true);
        mPhoenix.setSignalImage(resizedImg);


        // Initialize Firewalls
        mFirewall = new ArrayList<>();
        for (int i=0; i<numFirewall; i++){
            Firewall fw = new Firewall(i, mScreenX, mScreenY);
            mFirewall.add(fw);
        }

        // Initialize SuperMalware
        mSuperMalware = new SuperMalware(mScreenX, mScreenY);

        // This following lines of code get the image "supermalware.png", resize it to SuperMalware size, and passes it to Phoenix class for storage
        img = BitmapFactory.decodeResource(getResources(), R.drawable.supermalware);
        resizedImg = Bitmap.createScaledBitmap(img, mScreenX/7, mScreenX/7, true);
        mSuperMalware.setImg(resizedImg);

        mDropItem = new DropItem(mScreenX);
        // get the gesture detector
        mDoubleTapDetector = new GestureDetector(context,new OnSingleTapListener(mPhoenix));

        // Everything is ready so start the game
        startNewGame();

    }

    /**
     * Start a new game including the first time we start a first game or the player has just lost
     */
    private void startNewGame(){

        // start of a new level so make MalwareApps appear one level below the last one
        mLevel++;

        // put the malwareapps back to the starting position
        // The number of rows and columns of MalwareApp group are entirely arbitrary
        // For now, it is 3 rows and 6 columns, in total 18 MalwareApps
        for (int i = 0; i < 3; i++){
            for (int j = 0; j < 6; j++){
                mMalwareAppGroup.get(i*6+j).reset(j,i,mScreenX,mScreenY, mLevel);
            }
        }

        // Reset Firewall
        for (int i=0; i<numFirewall; i++){
            mFirewall.get(i).reset();
        }

        //Reset Pheonix
        mPhoenix.reset();

        // Reset the score and the player's chances
        mScore = 0;
        mLives = 3;

        // Reset SuperMalware
        smTimeReset = true;
        mSuperMalware.reset();
        mDropItem.setAlive(false);
    }


    /** When we start the thread with:
     mGameThread.start();
     Runs this once. While loop keeps it looping over.
     Calling mGameThread.join();
     waits for while loop to be over. */
    @Override
    public void run() {

        while (mPlaying) {

            // time now at the start of the game
            long frameStartTime = System.nanoTime();

            // Provided the game isn't paused
            // call the update method
            if (!mPaused) {

                // Check if all MalwareApps are dead, if so then start a new game
                boolean cont = false;
                for(MalwareApp ma : mMalwareAppGroup){
                    if(ma.isAlive()) {
                        cont = true;
                        break;
                    }
                }
                if (!cont) {
                    mPaused = true;
                    startNewGame();
                }

                // Reset start time for SuperMalware if true
                if(smTimeReset) {
                    smTimeReset = false;

                    // We'll generate a random number between 15-30 and display the SuperMalware at that time.
                    //int smDisplayTime = rand.nextInt(16) + 15;
                    smGoTime = rand.nextInt(6) + 5; // Remove this line after testing, this will make it appear randomly every 5 seconds

                    // We're using System.nanoTime() instead of System.currentTimeMillis() for better accuracy.
                    smRunTime = System.nanoTime();
                    //Log.d("STARTR", "smGoTime: " + smGoTime + ", smRunTime: " + (System.nanoTime() - smRunTime)/1000000000);
                }

                // Here we will check when that time occurs, and then send SuperMalware on the screen
                if (!mSuperMalware.isAlive()) {
                    //Log.d("SM1", "smGoTime: " + smGoTime + ", smRunTime: " + (System.nanoTime() - smRunTime)/1000000000);
                    if (smGoTime < (System.nanoTime() - smRunTime)/1000000000) {
                       // Log.d("SM2", "smGoTime: " + smGoTime + ", smRunTime: " + (System.nanoTime() - smRunTime)/1000000000);

                        // Reset puts the SuperMalware on 0 (left) or 1 (right) side of the screen to a fixed location on the screen
                        int side = rand.nextInt(2);
                        mSuperMalware.start(side);
                        //Log.d("START", "Side: " + side);
                    }
                }

                // First let's count the number of signals visible in the screen
                int msCount = 0;
                for (MalwareApp mApp: mMalwareAppGroup) {
                    if (mApp.mSignal.isAlive())
                        msCount++;
                }

                // now check if any MalwareApp wants to Fire Signal alternating from start (i) or last (j)
                for (MalwareApp mApp : mMalwareAppGroup) {
                    if (!mApp.mSignal.isAlive() && mApp.isAlive()) {
                        if (mApp.msType.getShootTime() < (System.nanoTime() - mApp.msType.signalTime)/1000000000) {
                            if (msCount < 3) {
                                mApp.fireSignal(mApp.msType.getVelocity());
                                msCount++;
                            } else {
                                mApp.msType.reset(System.nanoTime());
                            }
                        }
                    }
                }

                // Update locations of all objects
                update();

                // Check for various Collisions
                detectCollisions();
            }

            // The movement has been handled and collisions
            // detected now we can draw the scene
            draw();

            // How long did this frame/loop take?
            // Store the answer in timeThisFrame
            long timeThisFrame = (System.nanoTime() - frameStartTime)/1000000;

            // Make sure timeThisFrame is at least 1 millisecond
            // because accidentally dividing
            // by zero crashing the game
            if (timeThisFrame > 0) {
                // Store the current frame rate in mFPS
                // ready to pass to the update methods of
                // mBat and mBall next frame/loop

                // timeThisFrame can also be a constant and if less than 15 (approx), then it slows down the game.
                // Could be useful to know for later changes.
                mFPS = MILLIS_IN_SECOND/ timeThisFrame;
            }
        }
    }

    private void update() {
        // Update the entities of MalwareApp, SuperMalware and Phonenix3000 and Signals
        if (mPhoenix.isAlive()){
            if(!mPhoenix.isExploding){
                mPhoenix.update(mFPS);
            }
        }

        for (MalwareApp a : mMalwareAppGroup){
            //if (a.isVisible()){
                a.update(mFPS);
            //}
        }

        mPhoenix.updateSignals(mFPS);

        for (MalwareApp mApp : mMalwareAppGroup) {
            if (mApp.mSignal.isAlive()){
                mApp.mSignal.update(mFPS);
            }
        }

        if (mSuperMalware.isAlive()){
            mSuperMalware.update(mFPS);
        }

        if (mDropItem.isAlive()){
            mDropItem.update(mFPS);
        }
    }


    private void detectCollisions() {

        // Has the Phoenix signal hit MalwareApp, Firewall, SuperMalware, or top of the screen
        ArrayList<Signal> phoenixClip = mPhoenix.getClip();

        for (Signal signal : phoenixClip){
            if (signal.isAlive()) {
                // Has the Phoenix signal hit Malware app
                for (int i = 0; i < 18; i++){
                    if (mMalwareAppGroup.get(i).isAlive()) {
                        if (RectF.intersects(mMalwareAppGroup.get(i).getRect(), signal.getBetweenRect())) {
                            //Malware app should die
                            // We don't need Dying at all? Need to check on this at a later update
                            mMalwareAppGroup.get(i).setAlive(false);
                            //Phoenix Signal should die when it hit the malware app
                            signal.setAlive(false);

                            // Update score based on which type of Malware was hit. i(0) = 3 points, i(1) = 2 points, i(3) = 1 point.
                            if (i < 6) {
                                mScore = mScore + 3;
                            } else if (i < 12) {
                                mScore = mScore + 2;
                            } else {
                                mScore = mScore + 1;
                            }
                            break;
                        }
                    }
                }
                // Has the Phoenix signal hit Firewall block
                for (Firewall a : mFirewall) {
                    if (RectF.intersects(a.getRect(), signal.getBetweenRect())) {
                        if(a.checkCollision(signal.getBetweenRect())) {
                            //Phoenix Signal should die when it hits any Firewall block
                            signal.setAlive(false);
                            break;
                        }
                    }
                }
                // Has the Phoenix signal hit SuperMalware
                if (mSuperMalware.isAlive()) {
                    if(RectF.intersects(mSuperMalware.getRect(), signal.getBetweenRect())) {
                        smTimeReset = true;
                        mSuperMalware.reset();
                        mScore = mScore + 10;

                        int randomItem = rand.nextInt(2);
                        mDropItem.createItem((int)mSuperMalware.getRect().centerX(),(int)mSuperMalware.getRect().centerY(), mScreenY/2,randomItem,mContext);
                    }
                }
                // Has the Pheonix signal reach top of the screen
                if (signal.getBetweenRect().top < 0) {
                    // die when the signal went to top of the screen
                    signal.setAlive(false);
                }
            }
        }


        for (Signal s : phoenixClip){
            s.updateBetweenRect();
        }

        // Detect weapon collision
        if (mDropItem.isAlive()){
            int label = mDropItem.getLabel();
            if (mPhoenix.isAlive()) {
                if (RectF.intersects(mPhoenix.getRect(), mDropItem.getRect())) {
                    mDropItem.setAlive(false);
                    switch (label){
                        // WEAPON
                        case 0 :
                            mPhoenix.addSignal();
                            break;
                        // Health Potions
                        case 1:
                            // Maximum lives of Phoenix is three
                            if (mLives <= 3){
                                mLives++;
                            }
                            break;
                    }
                }
            }
            // Has the weapon hit bottom
            if(mDropItem.getRect().bottom > mScreenY){
                mDropItem.setAlive(false);
            }
        }





        // Has the Malware signal hit Firewall, Phoenix 3000, or bottom of the screen
        for (MalwareApp mApp : mMalwareAppGroup) {
            if (mApp.mSignal.isAlive()) {

                // Has the signal hit the bottom
                if (mApp.mSignal.getBetweenRect().top > mScreenY) {
                    // die when the signal went to top of the screen
                    mApp.mSignal.setAlive(false);
                    mApp.msType.reset(System.nanoTime());
                }

                // Has the signal hit a Firewall block
                for (Firewall a : mFirewall) {
                    if (RectF.intersects(a.getRect(), mApp.mSignal.getBetweenRect())) {
                        if(a.checkCollision(mApp.mSignal.getBetweenRect())) {
                            //Phoenix Signal should die when it hits any Firewall block
                            mApp.mSignal.setAlive(false);
                            mApp.msType.reset(System.nanoTime());
                            break;
                        }
                    }
                }

                // Has the Phoenix signal hit Phoenix 3000, then decrease a life
                if (mPhoenix.isAlive()) {
                    if(RectF.intersects(mPhoenix.getRect(), mApp.mSignal.getBetweenRect())) {
                        mV.vibrate(400);
                        mPhoenix.isExploding = true;
                        mApp.mSignal.setAlive(false);
                        mApp.msType.reset(System.nanoTime());
                        mLives--;
                    }
                }
            }
            mApp.mSignal.updateBetweenRect();
        }
        //Has MalwareInvader collides with the phoenix
        for(int i = 0; i < mMalwareAppGroup.size(); i++){
            if(mMalwareAppGroup.get(i).isAlive()){
                if(RectF.intersects(mPhoenix.getRect(), mMalwareAppGroup.get(i).getRect())) {
                    mPhoenix.isExploding = true;
                    mLives = 0;
                    mV.vibrate(1000);
                }
            }
        }

        // Has MalwareInvader hits the edge of the screen
        for (int i = 0; i < mMalwareAppGroup.size(); i++){
            if (mMalwareAppGroup.get(i).isAlive()){
                // Bottom
                if(mMalwareAppGroup.get(i).getRect().bottom > mScreenY){
                    mPaused = true;
                    mPlaying = false;
                    mV.vibrate(1000);
                    endGame();
                }

                // Top: MalwareApp won't reach the top of the screen

                // Left
                if(mMalwareAppGroup.get(i).getRect().left < 0) {
                    for (int j = 0; j < 18; j++){
                        mMalwareAppGroup.get(j).updateVerticalPosition(mScreenY);
                        mMalwareAppGroup.get(j).reverseXVelocity();
                        mMalwareAppGroup.get(j).increaseVelocity();
                        mMalwareAppGroup.get(j).update(mFPS);
                    }
                    break;
                }
                // Right
                if(mMalwareAppGroup.get(i).getRect().right > mScreenX){
                    for (int j = 0; j < 18; j++) {
                        mMalwareAppGroup.get(j).updateVerticalPosition(mScreenY);
                        mMalwareAppGroup.get(j).reverseXVelocity();
                        mMalwareAppGroup.get(j).increaseVelocity();
                        mMalwareAppGroup.get(j).update(mFPS);
                    }
                    break;
                }
            }
        }

        // Has SuperMalware hit the edge of the screen
        if (mSuperMalware.isAlive()) {
            if (mSuperMalware.getSide() == 0) {
                // Check if it hit the right side of the screen
                if(mSuperMalware.getRect().left > mScreenX) {
                    smTimeReset = true;
                    mSuperMalware.reset();
                }
            } else {
                // Check if it hit the left side of the screen
                if(mSuperMalware.getRect().right < 0) {
                    smTimeReset = true;
                    mSuperMalware.reset();
                }
            }

        }

        // Has a Malware hit any Firewall blocks? If yes, destroy those blocks.
        for(Firewall a: mFirewall){
            for(int j = 0; j < mMalwareAppGroup.size(); j++){
                if (mMalwareAppGroup.get(j).isAlive()) {
                    if (RectF.intersects(a.getRect(), mMalwareAppGroup.get(j).getRect())) {
                        //Firewall block should die
                        a.checkCollision(mMalwareAppGroup.get(j).getRect());
                    }
                }
            }
        }
    }

    protected void endGame() {
        ((MalwareInvaderActivity)mContext).endGame(mScore);
    }

    /**
     * In the future there will be a boundary detection so when MalwareApps hit the left and
     * right boundary, they change direction and move downwards.
     * When MalwareApps reach the bottom, gameover.
     */

    // This method is called by MalwareInvaderActivity
    // when the player quits the game
    public void pause() {
        // Set mPlaying to false
        // Stopping the thread isn't
        // always instant
        mPlaying = false;
        try {
            // Stop the thread
            mGameThread.join();
        } catch (InterruptedException e) {
            Log.e("Error:", "exiting thread");
        }
    }

    // This method is called by MalwareInvaderActivity
    // When the player starts the game
    public void resume(){
        mPlaying = true;
    }

    public void start(){
        mPlaying = true;
        // Initialize the instance of Thread
        mGameThread = new Thread(this);
        // Start the thread
        mGameThread.start();
    }

    /**
     * Draw the game objects and the HUD called from main game loop
     * drawing function which will reveal the new steps that we need to take to draw to the screen
     * 60 times per second
     */
    private void draw(){
        /* getSurface chained with a call to isValid : return true if it confirms that the area
         of memory which we want to manipulate to represent our frame of drawing is available
         This line of code check if other part of our code or Android itself is currently
         using the required portion of memory.*/
        if (mOurHolder.getSurface().isValid()) {
            // Lock the canvas (graphics memory) ready to draw
            // If another part of the code tries to access the memory while our code is accessing
            // it, it won't be able to
            mCanvas = mOurHolder.lockCanvas();

            // Fill the screen with a solid color
            // Current background color is black
            mCanvas.drawColor(Color.argb(255, 0, 0, 0));
            // Draw the game objects
            mPaint.setColor(Color.argb(255, 0, 0, 0));
            // Draw the Phoenix 3000, hopefully on top of Rect as it moves along with it
            if (mPhoenix.isAlive()){
                if(mPhoenix.explosionNumber < 6){
                    //mCanvas.drawRect(mPhoenix.getRect(),mPaint);
                    mCanvas.drawBitmap(mPhoenix.getImg(), mPhoenix.getImgX(), mPhoenix.getImgY(), mPaint);
                }

            }
            // draw weapon
            if (mDropItem.isAlive()){
                //mCanvas.drawRect(mPhoenix.getRect(),mPaint);
                mCanvas.drawBitmap(mDropItem.getImg(), mDropItem.getImgX(), mDropItem.getImgY(), mPaint);
            }

            //Draw the malware app
            for (MalwareApp a : mMalwareAppGroup) {
                if (a.isAlive()){
                    //mCanvas.drawRect(a.getRect(),mPaint);
                    mCanvas.drawBitmap(a.getImg(), a.getImgX(), a.getImgY(), mPaint);
                }
            }

            // Draw MalwareApp's signal
            mPaint.setColor(Color.argb(255, 0, 128, 0));
            for (MalwareApp mApp : mMalwareAppGroup) {
                if (mApp.mSignal.isAlive()) {
                    //mCanvas.drawRect(mApp.mSignal.getRect(), mPaint);
                    switch(mApp.msType.getType()) {
                        case 0: mCanvas.drawBitmap(slowVirus, mApp.mSignal.getImgX(), mApp.mSignal.getImgY(), mPaint);
                                break;
                        case 1: mCanvas.drawBitmap(mediumVirus, mApp.mSignal.getImgX(), mApp.mSignal.getImgY(), mPaint);
                            break;
                        case 2: mCanvas.drawBitmap(fastVirus, mApp.mSignal.getImgX(), mApp.mSignal.getImgY(), mPaint);
                            break;
                    }
                }
            }

            // Draw the SuperMalware if it's visible
            if (mSuperMalware.isAlive()) {
                //mCanvas.drawRect(mSuperMalware.getRect(), mPaint);
                mCanvas.drawBitmap(mSuperMalware.getImg(), mSuperMalware.getImgX(), mSuperMalware.getImgY(), mPaint);
            }

            //mPaint.setColor(Color.argb(255, 0, 50, 0));
            //mCanvas.drawRect(mPhoenix.mSignal.getBetweenRect(),mPaint);

            //Draw the phoenix signal
            mPaint.setColor(Color.argb(255, 0, 0, 0));
            ArrayList<Signal> phoenixClip = mPhoenix.getClip();
            for (Signal s : phoenixClip){
                if (s.isAlive()){
                    mCanvas.drawBitmap(s.getImg(), s.getImgX(), s.getImgY(), mPaint);
                }
            }

            // Draw the Firewalls
            //mPaint.setColor(Color.argb(255, 0, 128, 0));
            for (Firewall a : mFirewall) {
                //mCanvas.drawRect(a.getRect(), mPaint);
                a.drawBlocks(mCanvas, mPaint);
            }

            // Draw the text
            Typeface Arcade = Typeface.createFromAsset(assetManager, "fonts/hud.ttf");
            mPaint.setTypeface(Arcade);
            mPaint.setColor(Color.WHITE); // Could be changed later
            // Choose the font size
            mPaint.setTextSize(mFontSize);
            // Draw the HUD
            mCanvas.drawText("Scores: ", mFontMargin, mFontSize, mPaint);
            float score_width = mPaint.measureText("Scores: ");
            mPaint.setColor(Color.YELLOW); // Could be changed later
            mCanvas.drawText(""+ mScore, mFontMargin + score_width, mFontSize, mPaint);
            mPaint.setColor(Color.WHITE); // Could be changed later
            mCanvas.drawText("Lives: ",mFontMargin + mScreenX/2,mFontSize,mPaint);

            float lives_width = mPaint.measureText("Lives: ");
            img = BitmapFactory.decodeResource(getResources(), R.drawable.hearts);
            resizedImg = Bitmap.createScaledBitmap(img, mScreenX/20, mScreenX/15, true);
            for (int i = 0;i<mLives;i++){
                mCanvas.drawBitmap(resizedImg,mFontMargin + mScreenX/2+ lives_width + mScreenX/18*i, mScreenY/1000, mPaint);
            }


            if(mPhoenix.isExploding){
                mCanvas.drawBitmap(explosionArray[mPhoenix.explosionNumber-1], mPhoenix.getImgX(), mPhoenix.getImgY(), mPaint);
                mPhoenix.explosionNumber++;
                if(mPhoenix.explosionNumber == 12){
                    if (mLives == 0){
                        mPaused = true;
                        mPlaying = false;
                        endGame();
                    }
                    mPhoenix.reset();
                }
            }

            if (DEBUGGING) {
                printDebuggingText();
            }
            // Display the drawing on screen
            // unlockCanvasAndPost is a method of SurfaceView
            // This method sends our newly decorated Canvas object for drawing to the screen and
            // releases the lock so that other areas of code can use it again
            mOurHolder.unlockCanvasAndPost(mCanvas);
        }

    }

    // Handle all the screen touches
    @Override
    public  boolean onTouchEvent(MotionEvent motionEvent){

        // Get total pointer number.
        int totalPointerCount = motionEvent.getPointerCount();

        // get masked (not specific to a pointer) action
        int action = motionEvent.getActionMasked();

        if (this.mDoubleTapDetector.onTouchEvent(motionEvent)) {
            Log.d("TAG", "Single tap onset");
        }

        switch (action) {
            case MotionEvent.ACTION_DOWN: {
                Log.d("CV", "Pointer Down ");
                mPaused = false;
                final float x = motionEvent.getX();
                mLastTouchX = x;
                break;
            }

            case MotionEvent.ACTION_MOVE: {
                Log.d("CV", "Pointer Move ");
                final float x = motionEvent.getX();
                final float dx = x - mLastTouchX;
                if (dx > mScreenX / 100) {
                    mRightMoving = 0;
                    Log.d("Phoenix", "Moving Right");
                    mLeftMoving += Math.abs(dx);
                    mPhoenix.setMovementState(mPhoenix.RIGHT, mLeftMoving);
                } else if (dx < -mScreenX / 100) {
                    mLeftMoving = 0;
                    Log.d("Phoenix", "Moving Left");
                    mRightMoving += Math.abs(dx);
                    mPhoenix.setMovementState(mPhoenix.LEFT, mRightMoving);
                }
                invalidate();
                mLastTouchX = x;
                break;
            }

            case MotionEvent.ACTION_POINTER_DOWN: {
                Log.d("CV", "Other point down");
                break;
            }


            case MotionEvent.ACTION_POINTER_UP: {
                Log.d("CV", "Other point up");
                mPhoenix.tryFireSignal();
                mPhoenix.setMovementState(mPhoenix.STOPPED, 0);
                break;
            }


            case MotionEvent.ACTION_UP: {
                Log.d("CV", "Pointer up");
                mPhoenix.setMovementState(mPhoenix.STOPPED, 0);
                mRightMoving = 0;
                mLeftMoving = 0;
                break;
            }


            case MotionEvent.ACTION_CANCEL: {
                Log.d("CV", "Pointer cancle");
                mPhoenix.setMovementState(mPhoenix.STOPPED, 0);
            }
        }



        return true;
    }

    /**
     * Print debugging information
     */
    private void printDebuggingText(){
        // Hold a value that is half that of the member variable mFontSize
        int debugSize = mFontSize / 2;
        // A guess at a good position vertically to start printing the debugging text
        int debugStart = 150;
        mPaint.setTextSize(debugSize);
        mCanvas.drawText("FPS: " + mFPS, 10,debugStart + debugSize,mPaint);
    }



}
