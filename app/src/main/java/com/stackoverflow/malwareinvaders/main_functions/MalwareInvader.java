package com.stackoverflow.malwareinvaders.main_functions;

import android.content.Context;
import android.content.res.AssetManager;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.RectF;
import android.graphics.Typeface;
import android.util.Log;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.os.Vibrator;

import java.util.ArrayList;
import java.util.Random;

/**
 * SurfaceView is a descendant of View and now PongGame is, by inheritance, also a type of View
 * We can use SurfaceView from which our game class is derived to handel all our drawing requirements
 *
 */
public class MalwareInvader extends SurfaceView implements Runnable {
    /**
     * The DEBUGGING flag that tells if we want to debug code
     */
    private final boolean DEBUGGING = false;
    /**
     * Objects that we needed to do the drawing
     */
    private SurfaceHolder mOurHolder;
    private Canvas mCanvas;
    private Paint mPaint;
    // Hold context of MalwareInvaderActivity so we can end game
    private Context mContext;
    /**
     * The numbers of frames per second we get
     * Reinitialized every frame of animation around 60 times per second
     * It will be passed into each of the game objects (every frame of animation) so that
     * they can calcualte how much time has elapsed and can then derive how far to move
     */
    private long mFPS;
    /**
     * The number of milliseconds in a second
     * use this variable in calculations as it will make our code cleared .
     */
    private final int MILLIS_IN_SECOND = 1000;

    /**
     * Holds the resolution of the screen
     * mScreenX : hold the horizontal resolution of the screen
     * mScreenY : hold the vertical resolution of the screen
     */
    private int mScreenX;
    private int mScreenY;
    /**
     * The size of text we need
     */
    private int mFontSize;
    private int mFontMarginX;
    private int mFontMarginY;

    // Number of firewalls, can ask user for input to increase/decrease difficulty.
    // We should keep it between 0-3
    // Need to fix code to position the firewalls correctly depending on how many firewall it needs to fit on the screen.
    private int numFirewall = 3;
    /**
     * The game objects
     */
    Phoenix3000 mPhoenix;
    private MalwareAppGroup mMalwareAppGroup;
    private ArrayList<Firewall> mFirewall;
    private SuperMalware mSuperMalware;
    private DropItem mDropItem;
    private HUD mHUD;
    /**
     * The current score and lives remaining and which level user is on
     */
    private int mScore;
    private int mLives;
    private int mLevel;
    /** Here is the Thread and two control variables */
    private Thread mGameThread = null;
    /** This volatile variable can be accessed from inside and outside the thread*/
    private volatile boolean mPlaying ;
    private boolean mPaused = true;
    // We'll use this to randomize scores and time when SuperMalware appears
    Random rand = new Random();
    // This is used to keep track of what time from starting/createSignal time should SuperMalware fly.
    long smGoTime;
    // This is used to track the starting point of a time instance. After a random smGoTime after the smRunTime, SuperMalware will fly.
    long smRunTime;
    // This is used to hold if we need to createSignal our System.nanoTime() or not
    boolean smTimeReset = false;
    // asset manager
    AssetManager assetManager;
    // This is the vibrator class to control vibration
    Vibrator mV;
    // Hold the gesture listner that notifie users when a particular touch event has occurred.
    private GestureDetector mSingleTapDetector;
    private float mLastTouchX;
    // hold the total distance moving left
    private float mLeftMoving = 0;
    // hold the total distance moving right
    private float mRightMoving = 0;

    private String mDifficulty;
    private int numColumns;
    private int speedInit;
    private int superMalwareTime;
    private Bitmap backgroundimg;

    /**
     * The MalwareInvader constructor : Initialize the resolution size of the screen.
     * executed from MalwareInvaderActivity
     * @param context : providing MalwareInvader with a reference to android activity
     * @param x :  horizontal screen size in pixels
     * @param y : vertical screen size in pixels
     */
    public MalwareInvader (Context context, int x, int y, String Level){
        // Super .. calls the parent class : constructor of SurfaceView provided by Android
        super(context);
        this.mContext = context;
        mV = (Vibrator)getContext().getSystemService(Context.VIBRATOR_SERVICE);
        //Initialize game config
        mScore = 0;
        mLives = 2; // One life gets added at startNewGame
        mLevel = 0;
        //Initialize the resolution of screen with the values passed in as parameters
        mScreenX = x;
        mScreenY = y;
        // This mDifficulty is the userInput value to set the game mode
        mDifficulty = Level;
        // Font is 7% (1/15th) of screen width
        mFontSize = mScreenX / 15;
        // MarginX is 5% (1/20th) of screen width
        mFontMarginX = mScreenX / 20;
        // MarginY is 5% (1/20th) of screen width
        mFontMarginY = mScreenY / 20;
        // Initialize the objects ready for drawing with getHolder is a method of SurfaceView
        // GetHolder method returns a reference which is initialized to mHolder so mHolder is now
        // that reference
        mOurHolder = getHolder();
        mPaint = new Paint();
        assetManager = context.getAssets();

        //get the background img and resized to screen size
        backgroundimg = BitmapFactory.decodeResource(mContext.getResources(), R.drawable.background2);
        backgroundimg = Bitmap.createScaledBitmap(backgroundimg, mScreenX, mScreenY, true);

        /* Initialize the game objects */
        // Initialize malwareapp group
        // Depends on the difficulty setting, it will initialize 5,6,7 columns of MalwareApps
        switch (mDifficulty) {
            case "easy":
                numColumns = 5;
                speedInit = mScreenY;
                superMalwareTime = 0;
                break;
            case "medium":
                numColumns = 6;
                speedInit = mScreenY * 3 / 2;
                superMalwareTime = 5;
                break;
            case "hard":
                numColumns = 7;
                speedInit = mScreenY * 5 / 2;
                superMalwareTime = 10;
                break;
            default:
                numColumns = 6;
                speedInit = mScreenY * 3 / 2;
                superMalwareTime = 5;
        }

        mMalwareAppGroup = new MalwareAppGroup(mScreenX,mContext,numColumns);
        // Initialize Phoenix
        mPhoenix = new Phoenix3000(mScreenX,mScreenY,mContext);
        // Initialize Firewalls
        mFirewall = new ArrayList<>();
        for (int i=0; i<numFirewall; i++){
            Firewall fw = new Firewall(i, mScreenX, mScreenY);
            mFirewall.add(fw);
        }
        // Initialize SuperMalware
        mSuperMalware = new SuperMalware(mScreenX, mScreenY,mContext);
        // Initialize DropItem
        mDropItem = new DropItem(mScreenX);
        // Initialize my HUD class
        mHUD = new HUD(Typeface.createFromAsset(assetManager, "fonts/hud.ttf"),mFontSize,mFontMarginX,mFontMarginY,mContext,mScreenX,mScreenY);
        // get the gesture detector
        mSingleTapDetector = new GestureDetector(context,new OnSingleTapListener(mPhoenix));

        // Everything is ready so start the game
        startNewGame();
    }

    /**
     * Start a new game including the first time we start a first game or the player has just lost
     */
    private void startNewGame(){

        // start of a new level so make MalwareApps appear one level below the last one
        mLevel++;

        // give one extra life for clearing level
        if (mLives < 6){
            mLives++;
        }

        // put the malwareapps back to the starting position
        // The number of rows and columns of MalwareApp group are dependent on difficulty
        mMalwareAppGroup.reset(mScreenX, mScreenY, mLevel, numColumns);

        // Reset Firewall
        for (int i=0; i<numFirewall; i++){
            mFirewall.get(i).reset();
        }
        //Reset Pheonix
        mPhoenix.reset();
        // Reset SuperMalware
        smTimeReset = true;
        mSuperMalware.reset();
        mDropItem.setAlive(false);

    }


    /** When we start the thread with:
     mGameThread.start();
     Runs this once. While loop keeps it looping over.
     Calling mGameThread.join();
     waits for while loop to be over. */
    @Override
    public void run() {
        while (mPlaying) {
            // time now at the start of the game
            long frameStartTime = System.nanoTime();
            // Provided the game isn't paused
            // call the update method
            if (!mPaused) {
                // Check if all MalwareApps are dead, if so then start a new game
                if (mMalwareAppGroup.isAllMalmareAppDead()) {
                    mPaused = true;
                    mMalwareAppGroup.resetTime();
                    startNewGame();
                }
                // Reset start time for SuperMalware if true
                if(smTimeReset) {
                    smTimeReset = false;
                    // We'll generate a random number based on difficulty +- 10 seconds and display the SuperMalware at that time.
                    smGoTime = rand.nextInt(6) + superMalwareTime;
                    // We're using System.nanoTime() instead of System.currentTimeMillis() for better accuracy.
                    smRunTime = System.nanoTime();
                    Log.d("START", "smGoTime: " + smGoTime + ", smRunTime: " + (System.nanoTime() - smRunTime)/1000000000);
                }

                // Here we will check when that time occurs, and then send SuperMalware on the screen
                if (!mSuperMalware.isAlive()) {
                    Log.d("SM1", "smGoTime: " + smGoTime + ", smRunTime: " + (System.nanoTime() - smRunTime)/1000000000);
                    if (smGoTime < (System.nanoTime() - smRunTime)/1000000000) {
                        Log.d("SM2", "smGoTime: " + smGoTime + ", smRunTime: " + (System.nanoTime() - smRunTime)/1000000000);
                        // Reset puts the SuperMalware on 0 (left) or 1 (right) side of the screen to a fixed location on the screen
                        int side = rand.nextInt(2);
                        mSuperMalware.start(side);
                        Log.d("START", "Side: " + side);
                    }
                }

                // Now init speed of MalwareInvader depends on the userInput difficulty modes
                mMalwareAppGroup.tryFireSignal(speedInit);

                // Update locations of all objects
                update();

                // Check for various Collisions
                detectCollisions();
            }

            // The movement has been handled and collisions
            // detected now we can draw the scene
            draw();

            // How long did this frame/loop take?
            // Store the answer in timeThisFrame
            long timeThisFrame = (System.nanoTime() - frameStartTime)/1000000;

            // Make sure timeThisFrame is at least 1 millisecond
            // because accidentally dividing
            // by zero crashing the game
            if (timeThisFrame > 0) {
                // Store the current frame rate in mFPS
                // ready to pass to the update methods of
                // mBat and mBall next frame/loop

                // timeThisFrame can also be a constant and if less than 15 (approx), then it slows down the game.
                // Could be useful to know for later changes.
                mFPS = MILLIS_IN_SECOND/ timeThisFrame;
            }
        }
    }

    private void update() {
        // Update the entities of MalwareApp, SuperMalware and Phonenix3000 and Signals
        if (mPhoenix.isAlive()){
            if(!mPhoenix.isExploding){
                mPhoenix.update(mFPS);
            }
        }
        mMalwareAppGroup.update(mFPS);
        mPhoenix.updateSignals(mFPS);
        if (mSuperMalware.isAlive()){
            mSuperMalware.update(mFPS);
        }

        if (mDropItem.isAlive()){
            mDropItem.update(mFPS);
        }
    }


    private void detectCollisions() {
        // Has the Phoenix signal hit MalwareApp, Firewall, SuperMalware, or top of the screen
        ArrayList<Signal> phoenixClip = mPhoenix.getClip();
        for (Signal signal : phoenixClip){
            if (signal.isAlive()) {
                ArrayList<MalwareApp> MalwareAppGroup = mMalwareAppGroup.getmMalwareAppGroup();
                // Has the Phoenix signal hit Malware app
                for (int i = 0; i < 3*numColumns; i++){
                    if (MalwareAppGroup.get(i).isAlive()) {
                        if (RectF.intersects(MalwareAppGroup.get(i).getRect(), signal.getBetweenRect())) {
                            //Malware app should die
                            // We don't need Dying at all? Need to check on this at a later update
                            MalwareAppGroup.get(i).setAlive(false);
                            SoundManager.playEffect(1); // playEffect explosion effect
                            //Phoenix Signal should die when it hit the malware app
                            signal.setAlive(false);
                            // Update score based on which type of Malware was hit. i(0) = 3 points, i(1) = 2 points, i(3) = 1 point.
                            mScore = mScore + MalwareAppGroup.get(i).mValue;
                            break;
                        }
                    }
                }
                // Has the Phoenix signal hit Firewall block
                for (Firewall a : mFirewall) {
                    if (RectF.intersects(a.getRect(), signal.getBetweenRect())) {
                        if(a.checkCollision(signal.getBetweenRect())) {
                            //Phoenix Signal should die when it hits any Firewall block
                            signal.setAlive(false);
                            break;
                        }
                    }
                }
                // Has the Phoenix signal hit SuperMalware
                if (mSuperMalware.isAlive()) {
                    if(RectF.intersects(mSuperMalware.getRect(), signal.getBetweenRect())) {
                        smTimeReset = true;
                        mSuperMalware.reset();
                        mScore = mScore + 10;

                        int randomItem = rand.nextInt(2);
                        mDropItem.createItem((int)mSuperMalware.getRect().centerX(),(int)mSuperMalware.getRect().centerY(), mScreenY/2,randomItem,mContext);
                    }
                }
                // Has the Pheonix signal reach top of the screen
                if (signal.getBetweenRect().top < 0) {
                    // die when the signal went to top of the screen
                    signal.setAlive(false);
                }
            }
        }


        for (Signal s : phoenixClip){
            s.updateBetweenRect();
        }

        // Detect weapon collision
        if (mDropItem.isAlive()){
            int label = mDropItem.getLabel();
            if (mPhoenix.isAlive()) {
                if (RectF.intersects(mPhoenix.getRect(), mDropItem.getRect())) {
                    mDropItem.setAlive(false);
                    switch (label){
                        // WEAPON
                        case 0 :
                            // Maximum number of bullets is three
                            if(mPhoenix.getClip().size() <3) {
                                mPhoenix.addSignal();
                            }
                            break;
                        // Health Potions
                        case 1:
                            // Maximum lives of Phoenix is six
                            if (mLives < 6){
                                mLives++;
                            }
                            break;
                    }
                }
            }
            // Has the weapon hit bottom
            if(mDropItem.getRect().bottom > mScreenY){
                mDropItem.setAlive(false);
            }
        }

        ArrayList<MalwareApp> MalwareAppGroup = mMalwareAppGroup.getmMalwareAppGroup();
        // Has the Malware signal hit Firewall, Phoenix 3000, or bottom of the screen
        for (MalwareApp mApp :MalwareAppGroup) {
            if (mApp.mSignal.isAlive()) {
                // Has the signal hit the bottom
                if (mApp.mSignal.getBetweenRect().top > mScreenY) {
                    // die when the signal went to top of the screen
                    mApp.mSignal.setAlive(false);
                    mApp.mSignal.msType.reset(System.nanoTime());
                }
                // Has the signal hit a Firewall block
                for (Firewall a : mFirewall) {
                    if (RectF.intersects(a.getRect(), mApp.mSignal.getBetweenRect())) {
                        if (a.checkCollision(mApp.mSignal.getBetweenRect())) {
                            //Phoenix Signal should die when it hits any Firewall block
                            mApp.mSignal.setAlive(false);
                            mApp.mSignal.msType.reset(System.nanoTime());
                            break;
                        }
                    }
                }
                // Has the Malware signal hit Phoenix 3000, then decrease a life
                if (mPhoenix.isAlive()) {
                    if (RectF.intersects(mPhoenix.getRect(), mApp.mSignal.getBetweenRect())) {
                        mV.vibrate(400);
                        mPhoenix.isExploding = true;
                        SoundManager.playEffect(2); // playEffect explosion effect
                        mApp.mSignal.setAlive(false);
                        mApp.mSignal.msType.reset(System.nanoTime());
                        mLives--;
                        if (mLives == 0) {
                            mPaused = true;
                            mPlaying = false;
                            endGame();
                        }
                    }
                }
            }
            mApp.mSignal.updateBetweenRect();
        }

        for (MalwareApp mApp :MalwareAppGroup) {
            if (mApp.isAlive()){
                //Has MalwareInvader collides with the phoenix
                if(RectF.intersects(mPhoenix.getRect(), mApp.getRect())) {
                    mPhoenix.isExploding = true;
                    mPaused = true;
                    mPlaying = false;
                    mV.vibrate(1000);
                    endGame();
                    break;
                }
                // Has MalwareInvader hits the edge of the screen
                // Bottom
                if(mApp.getRect().bottom > mScreenY){
                    mPaused = true;
                    mPlaying = false;
                    mV.vibrate(1000);
                    endGame();
                    break;
                }
                // Top: MalwareApp won't reach the top of the screen
                // Left
                if(mApp.getRect().left < 0) {
                    for (int j = 0; j < 3*numColumns; j++){
                        MalwareAppGroup.get(j).updateVerticalPosition(mScreenY);
                        MalwareAppGroup.get(j).reverseXVelocity();
                        MalwareAppGroup.get(j).increaseVelocity();
                        MalwareAppGroup.get(j).update(mFPS);
                    }
                    break;
                }
                // Right
                if(mApp.getRect().right > mScreenX){
                    for (int j = 0; j < 3*numColumns; j++) {
                        MalwareAppGroup.get(j).updateVerticalPosition(mScreenY);
                        MalwareAppGroup.get(j).reverseXVelocity();
                        MalwareAppGroup.get(j).increaseVelocity();
                        MalwareAppGroup.get(j).update(mFPS);
                    }
                    break;
                }
            }
        }


        // Has SuperMalware hit the edge of the screen
        if (mSuperMalware.isAlive()) {
            if (mSuperMalware.getSide() == 0) {
                // Check if it hit the right side of the screen
                if(mSuperMalware.getRect().left > mScreenX) {
                    smTimeReset = true;
                    mSuperMalware.reset();
                }
            } else {
                // Check if it hit the left side of the screen
                if(mSuperMalware.getRect().right < 0) {
                    smTimeReset = true;
                    mSuperMalware.reset();
                }
            }

        }

        MalwareAppGroup = mMalwareAppGroup.getmMalwareAppGroup();
        // Has a Malware hit any Firewall blocks? If yes, destroy those blocks.
        for(Firewall a: mFirewall){
            for (MalwareApp mApp : MalwareAppGroup){
                if (mApp.isAlive()) {
                    if (RectF.intersects(a.getRect(), mApp.getRect())) {
                        //Firewall block should die
                        a.checkCollision(mApp.getRect());
                    }
                }
            }
        }
    }

    protected void endGame() {
        ((MalwareInvaderActivity) mContext).endGame(mScore);
    }

    /**
     * In the future there will be a boundary detection so when MalwareApps hit the left and
     * right boundary, they change direction and move downwards.
     * When MalwareApps reach the bottom, gameover.
     */

    // This method is called by MalwareInvaderActivity
    // when the player quits the game
    public void pause() {
        // Set mPlaying to false
        // Stopping the thread isn't
        // always instant
        mPlaying = false;
        try {
            // Stop the thread
            mGameThread.join();
        } catch (InterruptedException e) {
            Log.e("Error:", "exiting thread");
        }
    }

    public boolean sustainGame(){
        if(!mPaused){
            mPaused = true;
            return true;
        }else{
            mPaused = false;
            return false;
        }
    }

    // This method is called by MalwareInvaderActivity
    // When the player starts the game
    public void resume(){
        mPlaying = true;
    }

    public void start(){
        mPlaying = true;
        // Initialize the instance of Thread
        mGameThread = new Thread(this);
        // Start the thread
        mGameThread.start();
    }

    /**
     * Draw the game objects and the HUD called from main game loop
     * drawing function which will reveal the new steps that we need to take to draw to the screen
     * 60 times per second
     */
    private void draw(){
        /* getSurface chained with a call to isValid : return true if it confirms that the area
         of memory which we want to manipulate to represent our frame of drawing is available
         This line of code check if other part of our code or Android itself is currently
         using the required portion of memory.*/
        if (mOurHolder.getSurface().isValid()) {
            mCanvas = mOurHolder.lockCanvas();
            // Fill the screen with a background
            mCanvas.drawColor(Color.argb(255, 0, 0, 0));
            mCanvas.drawBitmap(backgroundimg, 0, 0, mPaint);
            // Draw the game objects
            mPaint.setColor(Color.argb(255, 0, 0, 0));
            // Draw the Phoenix 3000, hopefully on top of Rect as it moves along with it
            mPhoenix.draw(mCanvas,mPaint);
            // Reset Phoenix when Explosion effect finished
            if (mPhoenix.explosionNumber == 12) {
                mPhoenix.reset();
            }
            //Draw weapon
            mDropItem.draw(mCanvas,mPaint);
            //Draw the malware app
            mMalwareAppGroup.draw(mCanvas,mPaint);
            // Draw the SuperMalware
            mSuperMalware.draw(mCanvas,mPaint);
            // Draw the Firewalls
            for (Firewall a : mFirewall) {
                //mCanvas.drawRect(a.getRect(), mPaint);
                a.drawBlocks(mCanvas, mPaint);
            }
            // Draw the HUD
            mHUD.draw(mCanvas,mPaint,mLives,mScore,mPhoenix.getClip());

            // Print debugging info
            if (DEBUGGING) {
                printDebuggingText();
            }

            mOurHolder.unlockCanvasAndPost(mCanvas);
        }
    }

    // Handle all the screen touches
    @Override
    public  boolean onTouchEvent(MotionEvent motionEvent){
        // get masked (not specific to a pointer) action
        int action = motionEvent.getActionMasked();
        if (this.mSingleTapDetector.onTouchEvent(motionEvent)) {
            Log.d("TAG", "Single tap onset");
        }
        switch (action) {
            case MotionEvent.ACTION_DOWN: {
                Log.d("CV", "Pointer Down ");
                if(mPaused) {
                    // Let's unpause the game
                    mPaused = false;

                    // We want all the Malware App's to reset their current time
                    mMalwareAppGroup.resetTime();
                }
                final float x = motionEvent.getX();
                mLastTouchX = x;
                break;
            }
            case MotionEvent.ACTION_MOVE: {
                Log.d("CV", "Pointer Move ");
                final float x = motionEvent.getX();
                final float dx = x - mLastTouchX;
                if (dx > mScreenX / 100) {
                    mRightMoving = 0;
                    Log.d("Phoenix", "Moving Right");
                    mLeftMoving += Math.abs(dx);
                    mPhoenix.setMovementState(mPhoenix.RIGHT, mLeftMoving);
                } else if (dx < -mScreenX / 100) {
                    mLeftMoving = 0;
                    Log.d("Phoenix", "Moving Left");
                    mRightMoving += Math.abs(dx);
                    mPhoenix.setMovementState(mPhoenix.LEFT, mRightMoving);
                }
                invalidate();
                mLastTouchX = x;
                break;
            }
            case MotionEvent.ACTION_POINTER_DOWN: {
                Log.d("CV", "Other point down");
                break;
            }
            case MotionEvent.ACTION_POINTER_UP: {
                Log.d("CV", "Other point up");
                mPhoenix.tryFireSignal();
                mPhoenix.setMovementState(mPhoenix.STOPPED, 0);
                break;
            }
            case MotionEvent.ACTION_UP: {
                Log.d("CV", "Pointer up");
                mPhoenix.setMovementState(mPhoenix.STOPPED, 0);
                mRightMoving = 0;
                mLeftMoving = 0;
                break;
            }
        }

        return true;
    }

    /**
     * Print debugging information
     */
    private void printDebuggingText(){
        // Hold a value that is half that of the member variable mFontSize
        int debugSize = mFontSize / 2;
        // A guess at a good position vertically to start printing the debugging text
        int debugStart = 150;
        mPaint.setTextSize(debugSize);
        mCanvas.drawText("FPS: " + mFPS, 10,debugStart + debugSize,mPaint);
    }



}
