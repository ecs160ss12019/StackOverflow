package com.stackoverflow.malwareinvaders.main_functions;

import android.content.Context;
import android.content.res.AssetManager;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.RectF;
import android.graphics.Typeface;
import android.util.Log;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.os.Vibrator;

import java.util.ArrayList;
import java.util.Random;

/**
 * SurfaceView is a descendant of View and now PongGame is, by inheritance, also a type of View
 * We can use SurfaceView from which our game class is derived to handel all our drawing requirements
 */

/**
* MalwareInvader class implements our game loop which initializes the game thread, it controls the thread switching
* between the main activity class. It has update() to update objects' current status (lives, posions, ex). It has the 
* detectionCollision function which detects both collision between bullet an objects or collision between object and wall
* endGame which detects the end game and send score to main activity. Resume and pause to deal with context switching. 
* Draw() fucntion controls main drawing of the objects and Ontouch handles all the touch event.
*/
public class MalwareInvader extends SurfaceView implements Runnable {
    // GameConfig class holds all game variables and constant/magic numbers used in the game.
    GameConfig gameConf;
    // SurfaceHolder class to lock our canvas when drawing
    private SurfaceHolder mOurHolder;
    // Hold the gesture listener that notified users when a particular touch event has occurred.
    private GestureDetector mSingleTapDetector;
    // This is the vibrator class to control vibration
    protected Vibrator mV;
    //The game objects: package private
    Phoenix3000 mPhoenix;
    MalwareAppGroup mMalwareAppGroup;
    ArrayList<Firewall> mFirewall;
    SuperMalware mSuperMalware;
    DropItem mDropItem;
    HUD mHUD;
    // Here is the Thread and two control variables
    private Thread mGameThread = null;
    // This volatile variable can be accessed from inside and outside the thread
    private volatile boolean mPlaying ;
    private boolean mPaused = true;
    // Frame speed
    private long mFPS;
    private final int MILLIS_IN_SECOND = 1000;
    // We'll use this to randomize scores and time when SuperMalware appears
    Random rand = new Random();

    // This is constructor method
    public MalwareInvader (GameConfig gameConf){
        super(gameConf.mContext);
        this.gameConf = gameConf;
        mOurHolder = getHolder();
        // Initialize game objects
        mPhoenix = new Phoenix3000(gameConf.mScreenX,gameConf.mScreenY,gameConf.mContext);
        mMalwareAppGroup = new MalwareAppGroup(gameConf.mScreenX,gameConf.mContext,gameConf.numColumns);
        mFirewall = new ArrayList<>();
        for (int i=0; i<gameConf.numFirewall; i++){
            Firewall fw = new Firewall(i, gameConf.mScreenX, gameConf.mScreenY);
            mFirewall.add(fw);
        }
        mSuperMalware = new SuperMalware(gameConf.mScreenX,gameConf.mScreenY,gameConf.mContext);
        mDropItem = new DropItem(gameConf.mScreenX);
        mHUD = new HUD(Typeface.createFromAsset(gameConf.mContext.getAssets(), "fonts/hud.ttf"),gameConf);
        mV = (Vibrator)getContext().getSystemService(Context.VIBRATOR_SERVICE);
        mSingleTapDetector = new GestureDetector(gameConf.mContext,new OnSingleTapListener(mPhoenix));
        // Everything is ready so start the game
        startNewGame();
    }

    /**
     * Start a new game including the first time we start a first game or the player has just lost
     */
    private void startNewGame(){
        // start of a new level so make MalwareApps appear one level below the last one
        gameConf.mLevel++;
        // give one extra life for clearing level
        if (gameConf.mLives < 6){
            gameConf.mLives++;
        }
        // put the malwareapps back to the starting position
        // The number of rows and columns of MalwareApp group are dependent on difficulty
        mMalwareAppGroup.reset(gameConf.mScreenX, gameConf.mScreenY, gameConf.mLevel, gameConf.numColumns);
        // Reset Firewall
        for (int i=0; i<gameConf.numFirewall; i++){
            mFirewall.get(i).reset();
        }
        //Reset Pheonix
        mPhoenix.reset();
        // Reset SuperMalware
        mSuperMalware.reset();
        // Reset drop item
        mDropItem.setAlive(false);
    }


    /** When we start the thread with:
     mGameThread.start();
     Runs this once. While loop keeps it looping over.
     Calling mGameThread.join();
     waits for while loop to be over. */
    @Override
    public void run() {
        while (mPlaying) {
            // time now at the start of the game
            long frameStartTime = System.nanoTime();
            if (!mPaused) {
                // Check if all MalwareApps are dead, if so then start a new game
                if (mMalwareAppGroup.isAllMalmareAppDead()) {
                    mPaused = true;
                    mMalwareAppGroup.resetTime();
                    startNewGame();
                }
                // Reset start time for SuperMalware if true
                mSuperMalware.resetShwoingTime(gameConf,rand);
                // Now init speed of MalwareInvader depends on the userInput difficulty modes
                mMalwareAppGroup.tryFireSignal(gameConf.speedInit);
                // Update locations of all objects
                update();
                // Check for various Collisions
                detectCollisions();
            }
            // The movement has been handled and collisions
            // detected now we can draw the scene
            draw();
            long timeThisFrame = (System.nanoTime() - frameStartTime)/1000000;
            // Make sure timeThisFrame is at least 1 millisecond
            if (timeThisFrame > 0) {
                mFPS = MILLIS_IN_SECOND/ timeThisFrame;
            }
        }
    }

    private void update() {
        // Update the entities of MalwareApp, SuperMalware and Phonenix3000 and Signals
        if (mPhoenix.isAlive()){
            if(!mPhoenix.isExploding){
                mPhoenix.update(mFPS);
            }
        }
        for (Signal s : mPhoenix.getClip()){
            s.updateBetweenRect();
        }
        mMalwareAppGroup.update(mFPS);
        mPhoenix.updateSignals(mFPS);
        if (mSuperMalware.isAlive()){
            mSuperMalware.update(mFPS);
        }

        if (mDropItem.isAlive()){
            mDropItem.update(mFPS);
        }
    }

    private void detectCollisions() {
        // Has the Phoenix signal hit MalwareApp, Firewall, SuperMalware, or top of the screen
        mPhoenix.detectCollisions(this);
        // Detect weapon collision
        mDropItem.detectCollisions(this);
        // Has the Malware signal hit Firewall, Phoenix 3000, or bottom of the screen
        // Has Malware hit Phoenix or edge of screen
        mMalwareAppGroup.detectCollisions(this);
        // Has SuperMalware hit the edge of the screen
        mSuperMalware.detectCollisions(this);
        // Has a Malware hit any Firewall blocks? If yes, destroy those blocks.
        for(Firewall a: mFirewall){
            a.detectCollisions(this);
        }
    }

    void setmPaused(boolean value){mPaused = value;}

    void setmPlaying(boolean value){mPlaying = value;}

    long getmFPS(){return mFPS;}

    void endGame() {
        ((MalwareInvaderActivity) gameConf.mContext).endGame(gameConf.mScore);
    }

    /**
     * In the future there will be a boundary detection so when MalwareApps hit the left and
     * right boundary, they change direction and move downwards.
     * When MalwareApps reach the bottom, gameover.
     */
    public void pause() {
        mPlaying = false;
        try {
            mGameThread.join();
        } catch (InterruptedException e) {
        }
    }

    public boolean sustainGame(){
        if(!mPaused){
            mPaused = true;
            return true;
        }else{
            mPaused = false;
            return false;
        }
    }

    // This method is called by MalwareInvaderActivity
    // When the player starts the game
    public void resume(){
        mPlaying = true;
    }

    public void start(){
        mPlaying = true;
        // Initialize the instance of Thread
        mGameThread = new Thread(this);
        // Start the thread
        mGameThread.start();
    }

    /**
     * Draw the game objects and the HUD called from main game loop
     * drawing function which will reveal the new steps that we need to take to draw to the screen
     * 60 times per second
     */
    private void draw(){
        /* getSurface chained with a call to isValid : return true if it confirms that the area
         of memory which we want to manipulate to represent our frame of drawing is available
         This line of code check if other part of our code or Android itself is currently
         using the required portion of memory.*/
        if (mOurHolder.getSurface().isValid()) {
            gameConf.mCanvas = mOurHolder.lockCanvas();
            // Fill the screen with a background
            gameConf.mCanvas.drawColor(Color.argb(255, 0, 0, 0));
            gameConf.mCanvas.drawBitmap(gameConf.backgroundimg, 0, 0, gameConf.mPaint);
            // Draw the game objects
            gameConf.mPaint.setColor(Color.argb(255, 0, 0, 0));
            mPhoenix.draw(gameConf.mCanvas,gameConf.mPaint);
            // Reset Phoenix when Explosion effect finished
            if (mPhoenix.explosionNumber == 12) {
                mPhoenix.reset();
            }
            //Draw weapon
            mDropItem.draw(gameConf.mCanvas,gameConf.mPaint);
            //Draw the malware app
            mMalwareAppGroup.draw(gameConf.mCanvas,gameConf.mPaint);
            // Draw the SuperMalware
            mSuperMalware.draw(gameConf.mCanvas,gameConf.mPaint);
            // Draw the Firewalls
            for (Firewall a : mFirewall){
                a.drawBlocks(gameConf.mCanvas, gameConf.mPaint);
            }
            // Draw the HUD
            mHUD.draw(gameConf, mPhoenix.getClip());
            // Print debugging info
            if (gameConf.DEBUGGING) {
                printDebuggingText();
            }
            mOurHolder.unlockCanvasAndPost(gameConf.mCanvas);
        }
    }

    // Handle all the screen touches
    @Override
    public  boolean onTouchEvent(MotionEvent motionEvent){
        // get masked (not specific to a pointer) action
        int action = motionEvent.getActionMasked();
        if (mSingleTapDetector.onTouchEvent(motionEvent)) {
            Log.d("TAG", "Single tap onset");
        }
        switch (action) {
            case MotionEvent.ACTION_DOWN: {
                Log.d("CV", "Pointer Down ");
                if(mPaused) {
                    // Let's unpause the game
                    mPaused = false;

                    // We want all the Malware App's to reset their current time
                    mMalwareAppGroup.resetTime();
                }
                final float x = motionEvent.getX();
                gameConf.mLastTouchX = x;
                break;
            }
            case MotionEvent.ACTION_MOVE: {
                Log.d("CV", "Pointer Move ");
                final float x = motionEvent.getX();
                final float dx = x - gameConf.mLastTouchX;
                if (dx > gameConf.mScreenX / 100) {
                    gameConf.mRightMoving = 0;
                    Log.d("Phoenix", "Moving Right");
                    gameConf.mLeftMoving += Math.abs(dx);
                    mPhoenix.setMovementState(mPhoenix.RIGHT, gameConf.mLeftMoving);
                } else if (dx < -gameConf.mScreenX / 100) {
                    gameConf.mLeftMoving = 0;
                    Log.d("Phoenix", "Moving Left");
                    gameConf.mRightMoving += Math.abs(dx);
                    mPhoenix.setMovementState(mPhoenix.LEFT, gameConf.mRightMoving);
                }
                invalidate();
                gameConf.mLastTouchX = x;
                break;
            }
            case MotionEvent.ACTION_POINTER_DOWN: {
                Log.d("CV", "Other point down");
                break;
            }
            case MotionEvent.ACTION_POINTER_UP: {
                Log.d("CV", "Other point up");
                mPhoenix.tryFireSignal();
                mPhoenix.setMovementState(mPhoenix.STOPPED, 0);
                break;
            }
            case MotionEvent.ACTION_UP: {
                Log.d("CV", "Pointer up");
                mPhoenix.setMovementState(mPhoenix.STOPPED, 0);
                gameConf.mRightMoving = 0;
                gameConf.mLeftMoving = 0;
                break;
            }
        }

        return true;
    }

    /**
     * Print debugging information
     */
    private void printDebuggingText(){
        // Hold a value that is half that of the member variable mFontSize
        int debugSize = gameConf.mFontSize / 2;
        // A guess at a good position vertically to start printing the debugging text
        int debugStart = 150;
        gameConf.mPaint.setTextSize(debugSize);
        gameConf.mCanvas.drawText("FPS: " + mFPS, 10,debugStart + debugSize,gameConf.mPaint);
    }
}
