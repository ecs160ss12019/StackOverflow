package com.stackoverflow.malwareinvaders.main_functions;

/**
 * This is a blueprint of creating Phoenix3000 in game engine
 * On Sprint 1, the graphic representation of Phoenix3000 in game is just a rectangular
 * Phoenix3000 can move horizontally based on how user touch the screen
 * Phoenix3000 have a signal object to shot
 */

import android.graphics.Bitmap;
import android.graphics.RectF;

class Phoenix3000 extends Entities{

    /*
    These are the member variables. In the interests of good encapsulation, They are all private
    and are not visible/directly accessible from the Game Engine class because direct access
    is not required
     */
    private float mLength;
    private float mXCoord;
    private float mPhoenixSpeed;
    private int mScreenX;
    private int mScreenY;


    // This Signal object are public because they can be directly accessed by the game engine
    Signal mSignal;

    // I'm going to draw a Bitmap image of the Phoenix 3000 and want to store it's location
    private Bitmap image;
    private float imgXCord;
    private float imgYCord;

    // Some getters and setters because needs to be set original image to store it here and get to draw the image.
    Bitmap getImg(){ return image; }
    float getImgX() { return imgXCord; }
    float getImgY() { return imgYCord; }
    void setImg(Bitmap img) { image = img; }


    /**
     * These variables are public and final because they can be directly accessed by the instance
     * ( in game engine ) and they are part of the same package but cannot be changed
     * MalwareInvader class will keep the Phoenix class informed about its movement status
     * (left, right or stopped).
     *
     * The MalwareInvader class will be able to read their values (0,1 and 2) respectively and pass
     * them via a setter method to alter the value of the mPhoenixMoving variable that will be
     * read once per frame in the Phoenix class to determine how/if to move.
     */
    final int STOPPED = 0;
    final int LEFT = 1;
    final int RIGHT = 2;

    /**
     * Keep track of if and how the Phoenix is moving
     * Starting with STOPPED
     */
    private int mPhoenixMoving = STOPPED;
    private float mMovingThreshold = 0;
    // hold the total distance moving left
    private float mLeftMoving = 0;
    // hold the total distance moving right
    private float mRightMoving = 0;



    /**
     * This is a Constructor method that initialize the position of Phoenix when the game start up
     * @param sx: Horizontal resolution of the screen
     * @param sy: Vertical resolution of the screen
     */
    Phoenix3000(int sx,int sy){
        super();
        // Phoenix needs to know the screen horizontal resolution outside of this method
        mScreenX = sx;
        mScreenY = sy;

        // Configure the size of the Phoenix based on the screen resolution
        // The length of Phoenix is one eighth the screen width
        // mLength = mScreenX / 8; Old code, modified below
        mLength = mScreenX/8;

        // the height of Phoenix is one thirtieth the screen height
        // float height = sy / 30; Old code, modified below
        float height = mScreenX/8;

        // Configure the starting location of the Phoenix
        // The horizontal variable is a member and the vertical variable is local is because we only
        // need the vertical values for the duration of this method.
        // Roughly the middle horizontally
        mXCoord = mScreenX / 2;
        // The height of the Phoenix off the bottom of the screen
        // This will have the effect of placing the bottom of the Phoenix on the very bottom pixel
        // of the screen.
        float mYCoord = sy - height;

        // Initiliaze mRect based on the size and position
        // The four arguments passed into initialize the left , top, right and bottom coordinates of
        // the RectF, in that order
        mRect = new RectF(mXCoord, mYCoord,
                mXCoord + mLength,
                mYCoord + height);

        // Configure the speed of the Phoenix
        // This code means the Phoenix can cover the width of the screen in 1 second
        mPhoenixSpeed = mScreenX;


        // initiliaze the signal ready for the phoenix
        mSignal = new Signal(mScreenX);

        // Initialize location for Pheonix image which is the same as the rectangle
        imgXCord = mXCoord;
        imgYCord = sy - mLength;

    }

    /**
     * This is the RectF getter method so we can get access the position and size of the Phoenix
     * from the MalwareInvader class
     * @return : Return a reference to mRect to MalwareInvader
     * There is no access specifier which means it is default access and therefore accessible
     * via an instance of the Phoenix object used within the same package
     */
    RectF getRect(){
        return mRect;
    }

    // The following is coding the Phoenix helper methods

    /**
     * This is the setter method that will receive a value from MalwareInvader of either LEFT,RIGHT
     * or STOPPED
     * It set that value to mPhoenixMoving ready for later use.
     * @param state : the value of either LEFT,RIGHT or STOPPED
     */
    void setMovementState(int state,float dx){
        // Update the movement state passed in by the onTouchEvent method
        mPhoenixMoving = state;
        mMovingThreshold = dx;
    }

    /**
     * This is the setter method that trigger the Phoenix to fire the signal
     * If the signal is still visible on the screen, then the Phoenix can not fire the signal
     */
    void tryFireSignal(){
        if (!mSignal.isVisible()){
            mSignal.createSignal((int)mRect.centerX(),(int)mRect.centerY(), -mScreenY);
        }
    }



    /**
     * This is a update method that decide which direction to mode and update the Phoenix position
     * @param fps: current frames per second based on how long the previous frames took to execute
     */
    void update(long fps){
        // Move the Phoenix based on the mPhoenixMoving variable and the peed of the previous frame
        if (mPhoenixMoving == LEFT && mLeftMoving <= mMovingThreshold){
            mRightMoving = 0;
            mXCoord = mXCoord - (mPhoenixSpeed / fps);
            mLeftMoving += mPhoenixSpeed / fps;
        }
        if (mPhoenixMoving == RIGHT && mRightMoving <= mMovingThreshold){
            mLeftMoving = 0;
            mXCoord = mXCoord + (mPhoenixSpeed / fps);
            mRightMoving += mPhoenixSpeed / fps;
        }
        if (mPhoenixMoving == STOPPED){
            mLeftMoving = 0;
            mRightMoving = 0;
        }
        // Stop the phoenix going off the screen
        if (mXCoord < 0){
            mXCoord = 0;
        }else  if (mXCoord + mLength > mScreenX){
            mXCoord = mScreenX - mLength;
        }

        // Update mRect based on the results from the previous code in update
        mRect.left = mXCoord;
        mRect.right = mXCoord + mLength;

        // Update the Phoenix 3000 img location to match the rectangle location
        imgXCord = mXCoord;
    }

    void reset(){
        this.setVisible(true);
        this.setDying(false);
        mXCoord = mScreenX / 2;
        float height = mScreenX/8;
        float mYCoord = mScreenY - height;
        mRect = new RectF(mXCoord, mYCoord,
                mXCoord + mLength,
                mYCoord + height);
        imgXCord = mXCoord;
        imgYCord = mScreenY - mLength;
        // reset all the signal
        mSignal.setVisible(false);

    }

}
