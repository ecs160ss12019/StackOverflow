package com.stackoverflow.malwareinvaders.main_functions;

/**
 * This is a blueprint of creating Phoenix3000 in game engine
 * On Sprint 1, the graphic representation of Phoenix3000 in game is just a rectangular
 * Phoenix3000 can move horizontally based on how user touch the screen
 * Phoenix3000 have a signal object to shot
 */

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.RectF;

import java.util.ArrayList;

class Phoenix3000 extends Entities{
    private float mXCoord;
    private int mScreenX;
    private int mScreenY;
    public boolean isExploding = false;
    private Context mContext;
    Bitmap[] explosionArray = new Bitmap[12];
    // store the maximum number of signals
    private ArrayList<Signal> mClip;

    /**
     * These variables are public and final because they can be directly accessed by the instance
     * ( in game engine ) and they are part of the same package but cannot be changed
     * MalwareInvader class will keep the Phoenix class informed about its movement status
     * (left, right or stopped).
     *
     * The MalwareInvader class will be able to read their values (0,1 and 2) respectively and pass
     * them via a setter method to alter the value of the mPhoenixMoving variable that will be
     * read once per frame in the Phoenix class to determine how/if to move.
     */
    final int STOPPED = 0;
    final int LEFT = 1;
    final int RIGHT = 2;

    /**
     * Keep track of if and how the Phoenix is moving
     * Starting with STOPPED
     */
    private int mPhoenixMoving = STOPPED;
    private float mMovingThreshold = 0;
    // hold the total distance moving left
    private float mLeftMoving = 0;
    // hold the total distance moving right
    private float mRightMoving = 0;
    public int explosionNumber = 1;



    /**
     * This is a Constructor method that initialize the position of Phoenix when the game start up
     * @param sx : Horizontal resolution of the screen
     * @param sy : Vertical resolution of the screen
     * @param mContext
     */
    Phoenix3000(int sx, int sy, Context mContext){
        super();
        // Phoenix needs to know the screen horizontal resolution outside of this method
        mScreenX = sx;
        mScreenY = sy;
        // The length of Phoenix is one eighth the screen width
        width = mScreenX/8;
        // the height of Phoenix is one thirtieth the screen height
        height = mScreenX/8;
        // Configure the starting location of the Phoenix
        mXCoord = (mScreenX / 2) - (width / 2);
        // Initialize mRect based on the size and position
        mRect = new RectF(mXCoord,sy - height,mXCoord + width,sy - height + height);
        // Configure the speed of the Phoenix
        // This code means the Phoenix can cover the width of the screen in 1 second
        speed = mScreenX;
        // Initialize mclip
        mClip = new ArrayList<Signal>();
        // Set Phonix imgage
        this.mContext = mContext;
        // This following lines of code get the image "phoenix3000.png", resize it to Phoenix size,
        // and passes it to Phoenix class for storage
        setImg( BitmapFactory.decodeResource(mContext.getResources(), R.drawable.pheonix3000));
        // Get explosion id
        Integer[] explosionid = {
                R.drawable.explosion1,
                R.drawable.explosion2,
                R.drawable.explosion3,
                R.drawable.explosion4,
                R.drawable.explosion5,
                R.drawable.explosion6,
                R.drawable.explosion7,
                R.drawable.explosion8,
                R.drawable.explosion9,
                R.drawable.explosion10,
                R.drawable.explosion11,
                R.drawable.explosion12,
        };
        for(int i = 0; i < 12; ++i){
            Bitmap img = BitmapFactory.decodeResource(mContext.getResources(), explosionid[i]);
            img = Bitmap.createScaledBitmap(img, mScreenX/7, mScreenX/7, true);
            explosionArray[i] = img;
        }
    }

    /**
     * This is the setter method that will receive a value from MalwareInvader of either LEFT,RIGHT
     * or STOPPED
     * It set that value to mPhoenixMoving ready for later use.
     * @param state : the value of either LEFT,RIGHT or STOPPED
     */
    void setMovementState(int state,float dx){
        // Update the movement state passed in by the onTouchEvent method
        mPhoenixMoving = state;
        mMovingThreshold = dx;
    }

    /**
     * This is the setter method that trigger the Phoenix to fire the signal
     * If the signal is still visible on the screen, then the Phoenix can not fire the signal
     */
    void tryFireSignal(){
        for (Signal s : mClip){
            if (!s.isAlive()){
                SoundManager.playEffect(0);
                s.createSignal((int)mRect.centerX(),(int)mRect.centerY(), -mScreenY);
                break;
            }
        }
    }

    void addSignal(){
        SignalType msType = new SignalType(3);
        Signal s = new Signal(mScreenX,msType,mContext);
        mClip.add(s);
    }



    /**
     * This is a update method that decide which direction to mode and update the Phoenix position
     * @param fps: current frames per second based on how long the previous frames took to execute
     */
    void update(long fps){
        // Move the Phoenix based on the mPhoenixMoving variable and the peed of the previous frame
        if (mPhoenixMoving == LEFT && mLeftMoving <= mMovingThreshold){
            mRightMoving = 0;
            mXCoord = mXCoord - (speed / fps);
            mLeftMoving += speed / fps;
        }
        if (mPhoenixMoving == RIGHT && mRightMoving <= mMovingThreshold){
            mLeftMoving = 0;
            mXCoord = mXCoord + (speed / fps);
            mRightMoving += speed / fps;
        }
        if (mPhoenixMoving == STOPPED){
            mLeftMoving = 0;
            mRightMoving = 0;
        }
        // Stop the phoenix going off the screen
        if (mXCoord < 0){
            mXCoord = 0;
        }else  if (mXCoord + width > mScreenX){
            mXCoord = mScreenX - width;
        }
        // Update mRect based on the results from the previous code in update
        mRect.left = mXCoord;
        mRect.right = mXCoord + width;
        // Update the Phoenix 3000 img location to match the rectangle location
        imgXCord = mXCoord;
    }

    void reset(){
        isExploding = false;
        explosionNumber = 1;
        setAlive(true);
        mXCoord = (mScreenX / 2) - (width / 2);
        float mYCoord = mScreenY - height - (mScreenY/50);
        mRect = new RectF(mXCoord, mYCoord,
                mXCoord + width,
                mYCoord + height);
        imgXCord = mXCoord;
        imgYCord = mYCoord;
        // reset all the signal and mclip
        mClip.clear();
        SignalType msType = new SignalType(3);
        Signal mSignal = new Signal(mScreenX,msType,mContext);
        mClip.add(mSignal);
    }

    void updateSignals(long mFPS) {
        for(Signal s : mClip){
            if (s.isAlive()){
                s.update(mFPS);
            }
        }
    }

    void draw(Canvas mCanvas, Paint mPaint){
        if (this.isAlive()){
            if(this.explosionNumber < 6){
                //mCanvas.drawRect(mPhoenix.getRect(),mPaint);
                mCanvas.drawBitmap(this.getImg(), this.getImgX(), this.getImgY(), mPaint);
            }
        }
        if(this.isExploding) {
            mCanvas.drawBitmap(explosionArray[this.explosionNumber - 1], this.getImgX(), this.getImgY(), mPaint);
            this.explosionNumber++;

        }

        //Draw the phoenix signal
        for (Signal s : mClip){
            if (s.isAlive()){
                mCanvas.drawBitmap(s.getImg(), s.getImgX(), s.getImgY(), mPaint);
            }
        }

    }


    ArrayList<Signal> getClip(){
        return mClip;
    }

}
