package com.stackoverflow.malwareinvaders;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.RectF;
import android.util.Log;
import android.view.MotionEvent;
import android.view.SurfaceHolder;
import android.view.SurfaceView;

import java.util.ArrayList;

/**
 * SurfaceView is a descendant of View and now PongGame is, by inheritance, also a type of View
 * We can use SurfaceView from which our game class is derived to handel all our drawing requirements
 *
 */
public class MalwareInvader  extends SurfaceView implements Runnable {
    /**
     * The DEBUGGING flag that tells if we want to debug code
     */
    private final boolean DEBUGGING = true;

    /**
     * Objects that we needed to do the drawing
     */
    private SurfaceHolder mOurHolder;
    private Canvas mCanvas;
    private Paint mPaint;

    /**
     * The numbers of frames per second we get
     * Reinitialized every frame of animation around 60 times per second
     * It will be passed into each of the game objects (every frame of animation) so that
     * they can calcualte how much time has elapsed and can then derive how far to move
     */
    private long mFPS;
    /**
     * The number of milliseconds in a second
     * use this variable in calculations as it will make our code cleared .
     */
    private final int MILLIS_IN_SECOND = 1000;

    /**
     * Holds the resolution of the screen
     * mScreenX : hold the horizontal resolution of the screen
     * mScreenY : hold the vertical resolution of the screen
     */
    private int mScreenX;
    private int mScreenY;
    /**
     * The size of text we need
     */
    private int mFontSize;
    private int mFontMargin;

    // Number of firewalls, can ask user for input to increase/decrease difficulty.
    // We should keep it between 0-3
    // Need to fix code to position the firewalls correctly depending on how many firewall it needs to fit on the screen.
    private int numFirewall = 3;

    /**
     * The game objects
     */
    private Phoenix3000 mPhoenix;
    private ArrayList<MalwareApp> mMalwareAppGroup;
    private ArrayList<Firewall> mFirewall;
    private SuperMalware mSuperMalware;

    /**
     * The current score and lives remaining
     */
    private int mScore;
    private int mLives;

    /** Here is the Thread and two control variables */
    private Thread mGameThread = null;
    /** This volatile variable can be accessed from inside and outside the thread*/
    private volatile boolean mPlaying ;
    private boolean mPaused = true;

    /**
     * The MalwareInvader constructor : Initialize the resolution size of the screen.
     * executed from MalwareInvaderActivity
     * @param context : providing MalwareInvader with a reference to android activity
     * @param x :  horizontal screen size in pixels
     * @param y : vertical screen size in pixels
     */
    public MalwareInvader (Context context, int x, int y){
        // Super .. calls the parent class : constructor of SurfaceView provided by Android
        super(context);
        //Initialize the resolution of screen with the values passed in as parameters
        mScreenX = x;
        mScreenY = y;
        // Font is 5% (1/20th) of screen width
        mFontSize = mScreenX / 20;
        // Margin is 1.5% (1/75th) of screen width
        mFontMargin = mScreenX / 75;

        // Initialize the objects ready for drawing with getHolder is a method of SurfaceView
        // GetHolder method returns a reference which is initialized to mHolder so mHolder is now
        // that reference
        mOurHolder = getHolder();
        mPaint = new Paint();

        /* Initialize the game objects */
        // Initialize malwareapp group
        mMalwareAppGroup = new ArrayList<>();
        for (int i = 0; i < 3; i++){
            for (int j = 0; j < 6; j++){
                MalwareApp mMalwareApp = new MalwareApp(mScreenX);
                mMalwareApp.reset(j,i,mScreenX,mScreenY);
                mMalwareAppGroup.add(mMalwareApp);
            }
        }

        // Initialize Phoenix
        mPhoenix = new Phoenix3000(mScreenX,mScreenY);

        // This following lines of code get the image "phoenix3000.png", resize it to 200x200, and passes it to Phoenix class for storage
        Bitmap img = BitmapFactory.decodeResource(getResources(), R.drawable.pheonix3000);
        Bitmap resizedImg = Bitmap.createScaledBitmap(img, mScreenX/10, mScreenX/10, true);
        mPhoenix.setImg(resizedImg);

        // Initialize Firewalls
        mFirewall = new ArrayList<>();
        for (int i=0; i<numFirewall; i++){
            Firewall fw = new Firewall(i, mScreenX, mScreenY);
            mFirewall.add(fw);
        }

        // Everything is ready so start the game
        startNewGame();
    }

    /**
     * Start a new game including the first time we start a first game or the player has just lost
     */
    private void startNewGame(){

        // put the malwareapps back to the starting position
        // The number of rows and columns of MalwareApp group are entirely arbitrary
        // For now, it is 3 rows and 6 columns, in total 18 MalwareApps
        for (int i = 0; i < 3; i++){
            for (int j = 0; j < 6; j++){
                mMalwareAppGroup.get(i*6+j).reset(j,i,mScreenX,mScreenY);
            }
        }

        // Reset Firewall
        for (int i=0; i<numFirewall; i++){
            mFirewall.get(i).reset();
        }

        // Reset the score and the player's chances
        mScore = 0;
        mLives = 3;

    }


    /** When we start the thread with:
     mGameThread.start();
     the run method is continuously called by Android
     because we implemented the Runnable interface
     Calling mGameThread.join();
     will stop the thread */
    @Override
    public void run() {
        // mPlaying gives us finer control
        // rather than just relying on  the calls to run
        // mPlaying must be true AND
        // the thread running for the main
        // loop to execute
        while (mPlaying) {
            // time now at the start of the loop
            long frameStartTime = System.currentTimeMillis();

            // Provided the game isn't paused
            // call the update method
            if (!mPaused) {
                update();
                // Now the bat and ball are in
                // their new positions
                // we can see if there have
                // been any collisions
                detectCollisions();
            }

            // The movement has been handled and collisions
            // detected now we can draw the scene
            draw();

            // How long did this frame/loop take?
            // Store the answer in timeThisFrame
            long timeThisFrame = System.currentTimeMillis() - frameStartTime;

            // Make sure timeThisFrame is at least 1 millisecond
            // because accidentally dividing
            // by zero crashing the game
            if (timeThisFrame > 0) {
                // Store the current frame rate in mFPS
                // ready to pass to the update methods of
                // mBat and mBall next frame/loop
                mFPS = MILLIS_IN_SECOND/ timeThisFrame;
            }
        }
    }

    private void update() {
        // Update the entities of MalwareApp, SuperMalware and Phonenix3000 and Signals
        if (mPhoenix.isVisible()){
            mPhoenix.update(mFPS);
        }

        for (MalwareApp a : mMalwareAppGroup){
            if (a.isVisible()){
                a.update(mFPS);
            }
        }

        if (mPhoenix.mSignal.isVisible()){
            mPhoenix.mSignal.update(mFPS);
        }
    }


    private void detectCollisions() {
        // Has the signal hit any MalwareApp

        // Has the signal hit any SuperMalware

        // Has the signal hit the firewall

        // Has the Malware signal hit something

        // Has the Phoenix signal hit something
        if (mPhoenix.mSignal.isVisible()) {
            // Has the Phoenix signal hit Malware app
            for (MalwareApp a : mMalwareAppGroup) {
                if (a.isVisible()){
                    if (RectF.intersects(a.getRect(), mPhoenix.mSignal.getRect())) {
                        //Malware app should die
                        a.setDying(true);
                        //Phoenix Signal should die when it hit the malware app
                        mPhoenix.mSignal.die();
                        mScore++;
                    }
                }
            }

            // Has the Phoenix signal hit Firewall block
            for (Firewall a : mFirewall) {
                if (RectF.intersects(a.getRect(), mPhoenix.mSignal.getRect())) {
                    if(a.checkCollision(mPhoenix.mSignal.getRect())) {
                        //Phoenix Signal should die when it hits any Firewall block
                        mPhoenix.mSignal.die();
                    }
                }
                }
            }

            // Has the Pheonix signal reach top of the screen
            if (mPhoenix.mSignal.getRect().top < 0) {
                // die when the signal went to top of the screen
                mPhoenix.mSignal.die();
            }

        // Has MalwareInvader hits the edge of the screen
        for (int i = 0; i < 18; i++){
            // Bottom
            if (mMalwareAppGroup.get(i).isVisible()){
                if(mMalwareAppGroup.get(i).getRect().bottom > mScreenY){
                    mPaused = true;
                    startNewGame();
                }
                // Top: MalwareApp won't reach the top of the screen
                // Left
                if(mMalwareAppGroup.get(i).getRect().left < 0) {
                    for (int j = 0; j < 18; j++){
                        mMalwareAppGroup.get(j).updateVerticalPosition(mScreenY);
                        mMalwareAppGroup.get(j).reverseXVelocity();
                    }
                }
                // Right
                if(mMalwareAppGroup.get(i).getRect().right > mScreenX){
                    for (int j = 0; j < 18; j++){
                        mMalwareAppGroup.get(j).updateVerticalPosition(mScreenY);
                        mMalwareAppGroup.get(j).reverseXVelocity();
                    }
                }
            }
        }

        for(Firewall a: mFirewall){
            for(int j = 0; j < mMalwareAppGroup.size(); j++){
                if (RectF.intersects(a.getRect(), mMalwareAppGroup.get(j).getRect())) {
                    //Firewallblock should die
                    a.checkCollision(mMalwareAppGroup.get(j).getRect());
                    //mFirewall.blocks.remove(i);
                }
            }
        }


    }

    /**
     * In the future there will be a boundary detection so when MalwareApps hit the left and
     * right boundary, they change direction and move downwards.
     * When MalwareApps reach the bottom, gameover.
     */

    // This method is called by MalwareInvaderActivity
    // when the player quits the game
    public void pause() {
        // Set mPlaying to false
        // Stopping the thread isn't
        // always instant
        mPlaying = false;
        try {
            // Stop the thread
            mGameThread.join();
        } catch (InterruptedException e) {
            Log.e("Error:", "joining thread");
        }
    }

    // This method is called by MalwareInvaderActivity
    // When the player starts the game
    public void resume(){
        mPlaying = true;
        // Initialize the instance of Thread
        mGameThread = new Thread(this);
        // Start the thread
        mGameThread.start();
    }

    /**
     * Draw the game objects and the HUD called from main game loop
     * drawing function which will reveal the new steps that we need to take to draw to the screen
     * 60 times per second
     */
    private void draw(){
        /* getSurface chained with a call to isValid : return true if it confirms that the area
         of memory which we want to manipulate to represent our frame of drawing is available
         This line of code check if other part of our code or Android itself is currently
         using the required portion of memory.*/
        if (mOurHolder.getSurface().isValid()) {
            // Lock the canvas (graphics memory) ready to draw
            // If another part of the code tries to access the memory while our code is accessing
            // it, it won't be able to
            mCanvas = mOurHolder.lockCanvas();

            // Fill the screen with a solid color
            // Current background color is black
            mCanvas.drawColor(Color.argb(255, 0, 0, 0));

            // Draw the game objects
            mPaint.setColor(Color.argb(255, 0, 0, 0));
            // Draw the Phoenix 3000, hopefully on top of Rect as it moves along with it
            if (mPhoenix.isVisible()){
                mCanvas.drawRect(mPhoenix.getRect(),mPaint);
                mCanvas.drawBitmap(mPhoenix.getImg(), mPhoenix.getImgX(), mPhoenix.getImgY(), mPaint);
            }

            //Draw the malware app
            mPaint.setColor(Color.argb(255, 0, 128, 0));
            for (MalwareApp a : mMalwareAppGroup) {
                if (a.isVisible()){
                    mCanvas.drawRect(a.getRect(),mPaint);
                }
            }

            //Draw the phoenix signal
            mPaint.setColor(Color.argb(255, 0, 128, 0));
            if (mPhoenix.mSignal.isVisible()){
                mCanvas.drawRect(mPhoenix.mSignal.getRect(),mPaint);
            }

            // Draw the Firewalls
            for (Firewall a : mFirewall) {
                a.drawBlocks(mCanvas, mPaint);
            }

            // Draw the text
            mPaint.setColor(Color.YELLOW); // Could be changed later
            // Choose the font size
            mPaint.setTextSize(mFontSize);
            // Draw the HUD
            mCanvas.drawText("Scores: " + mScore + "  " + "Lives: " + mLives, mFontMargin, mFontSize, mPaint);

            if (DEBUGGING) {
                printDebuggingText();
            }
            // Display the drawing on screen
            // unlockCanvasAndPost is a method of SurfaceView
            // This method sends our newly decorated Canvas object for drawing to the screen and
            // releases the lock so that other areas of code can use it again
            mOurHolder.unlockCanvasAndPost(mCanvas);
        }

    }

    // Handle all the screen touches
    @Override
    public  boolean onTouchEvent(MotionEvent motionEvent){
        // This switch block
        switch (motionEvent.getAction()&MotionEvent.ACTION_MASK){
            // The player has put their finger on the screen
            case MotionEvent.ACTION_DOWN:
                // If the game was paused then unpause
                mPaused = false;

                // Where did the touch happen
                if (motionEvent.getX()  >  mPhoenix.getRect().right ){
                    // On the right hand side
                    // The phoenix will move to right if the user touch at the point where it is
                    // on the right from the phoenix center point
                    mPhoenix.setMovementState(mPhoenix.RIGHT);
                }else if (motionEvent.getX() < mPhoenix.getRect().right && motionEvent.getX() > mPhoenix.getRect().left){
                    mPhoenix.tryFireSignal();
                } else{
                    // on the left hand side
                    mPhoenix.setMovementState(mPhoenix.LEFT);
                }
                break;

            // The player lifted their finger
            // from anywhere on screen.
            // It is possible to create bugs by using
            // multiple fingers. We will use more
            // complicated and robust touch handling
            // in later projects
            case MotionEvent.ACTION_UP:
                // Stop the bat moving
                mPhoenix.setMovementState(mPhoenix.STOPPED);
                break;
        }
        return true;

    }

    /**
     * Print debugging information
     */
    private void printDebuggingText(){
        // Hold a value that is half that of the member variable mFontSize
        int debugSize = mFontSize / 2;
        // A guess at a good position vertically to start printing the debugging text
        int debugStart = 150;
        mPaint.setTextSize(debugSize);
        mCanvas.drawText("FPS: " + mFPS, 10,debugStart + debugSize,mPaint);
    }



}
